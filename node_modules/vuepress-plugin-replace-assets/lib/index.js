// src/normalizeRules.ts
import { isArray, isFunction } from "@vuepress/helper";

// src/constants.ts
var PLUGIN_NAME = "vuepress-plugin-replace-assets";
var KNOWN_IMAGE_EXTENSIONS = [
  "png",
  "jpg",
  "jpeg",
  "gif",
  "webp",
  "svg",
  "avif"
];
var KNOWN_MEDIA_EXTENSIONS = [
  "mp4",
  "webm",
  "ogg",
  "mp3",
  "wav",
  "flac",
  "aac",
  "m3u8",
  "m3u",
  "flv",
  "pdf"
];
var KNOWN_ASSET_EXTENSIONS = [
  ...KNOWN_IMAGE_EXTENSIONS,
  ...KNOWN_MEDIA_EXTENSIONS
];

// src/normalizeRules.ts
function createFindPattern(extensions) {
  return new RegExp(`\\.(?:${extensions.join("|")})(\\?.*)?$`);
}
function normalizeRules(options) {
  const normalized = [];
  if (typeof options === "string" || isFunction(options)) {
    options && normalized.push({
      find: createFindPattern(KNOWN_ASSET_EXTENSIONS),
      replacement: options
    });
    return normalized;
  }
  if (isArray(options)) {
    normalized.push(...options);
    return normalized;
  }
  if ("find" in options) {
    options.find && options.replacement && normalized.push(options);
    return normalized;
  }
  if (options.image) {
    normalized.push({
      find: createFindPattern(KNOWN_IMAGE_EXTENSIONS),
      replacement: options.image
    });
  }
  if (options.media) {
    normalized.push({
      find: createFindPattern(KNOWN_MEDIA_EXTENSIONS),
      replacement: options.media
    });
  }
  if (options.all) {
    normalized.push({
      find: createFindPattern(KNOWN_ASSET_EXTENSIONS),
      replacement: options.all
    });
  }
  if (options.rules) {
    normalized.push(...isArray(options.rules) ? options.rules : [options.rules]);
  }
  return normalized;
}

// src/plugin.ts
import { addViteConfig, chainWebpack, getBundlerName } from "@vuepress/helper";

// src/unplugin/index.ts
import {
  createVitePlugin as _createVitePlugin,
  createWebpackPlugin as _createWebpackPlugin
} from "unplugin";

// src/unplugin/transform.ts
import MagicString from "magic-string";

// src/unplugin/utils.ts
import { removeEndingSlash, removeLeadingSlash } from "@vuepress/helper";
function createAssetPattern(prefix) {
  const s = `(${prefix}.*?)`;
  return new RegExp(
    [
      `(?:"${s}")`,
      // "prefix"
      `(?:'${s}')`,
      // 'prefix'
      `(?:\\(${s}\\))`,
      // (prefix)
      `(?:\\('${s}'\\))`,
      // ('prefix')
      `(?:\\("${s}"\\))`,
      // ("prefix")
      `(?:\\\\"${s}\\\\")`
      // \"prefix\"
    ].join("|"),
    "gu"
  );
}
var htmlLangRE = /\.(?:html|htm)$/;
var isHTMLRequest = (request) => htmlLangRE.test(request);
var nonJsRe = /\.json(?:$|\?)/;
function isNonJsRequest(request) {
  return nonJsRe.test(request);
}
function normalizeUrl(url, base) {
  if (!url)
    return "";
  if (base) {
    url = `${removeEndingSlash(base)}/${removeLeadingSlash(url)}`;
  }
  return url;
}

// src/unplugin/transform.ts
var cache = /* @__PURE__ */ new Map();
function transformAssets(code, pattern, rules) {
  const s = new MagicString(code);
  let matched;
  let hasMatched = false;
  while (matched = pattern.exec(code)) {
    const assetUrl = matched[6] || matched[5] || matched[4] || matched[3] || matched[2] || matched[1];
    const [left, right] = matched[0].startsWith("(") ? ['("', '")'] : matched[0].startsWith('\\"') ? ['\\"', '\\"'] : ['"', '"'];
    const start = matched.index;
    const end = start + matched[0].length;
    const resolved = replacementAssetWithRules(rules, assetUrl);
    if (resolved) {
      hasMatched = true;
      s.update(start, end, `${left}${resolved}${right}`);
    }
  }
  if (!hasMatched)
    return code;
  return s.toString();
}
function replacementAssetWithRules(rules, url) {
  if (cache.has(url))
    return cache.get(url);
  for (const { find, replacement } of rules) {
    if (find && isMatchUrl(find, url)) {
      let replaced = "";
      if (typeof replacement === "function") {
        replaced = normalizeUrl(replacement(url));
      } else {
        replaced = normalizeUrl(url, replacement);
      }
      if (replaced) {
        cache.set(url, replaced);
        return replaced;
      }
    }
  }
  return void 0;
}
function isMatchUrl(find, url) {
  if (typeof find === "string") {
    if (find[0] === "^" || find[find.length - 1] === "$") {
      return new RegExp(find).test(url);
    } else {
      return url.endsWith(find) || url.startsWith(find);
    }
  }
  return find.test(url);
}

// src/unplugin/factory.ts
var unpluginFactory = (rules) => {
  const plugins = [];
  if (rules.length) {
    plugins.push({
      name: "vuepress:replace-assets",
      enforce: "pre",
      transformInclude(id) {
        if (isHTMLRequest(id) || isNonJsRequest(id))
          return false;
        return true;
      },
      transform(code) {
        return {
          code: transformAssets(
            code,
            createAssetPattern("/[^/]"),
            rules
          )
        };
      }
    });
  }
  return plugins;
};

// src/unplugin/index.ts
var createVitePlugin = () => _createVitePlugin(unpluginFactory);
var createWebpackPlugin = () => _createWebpackPlugin(unpluginFactory);

// src/plugin.ts
var EMPTY_PLUGIN = { name: PLUGIN_NAME };
function replaceAssetsPlugin(options = {}) {
  const rules = normalizeRules(options);
  if (rules.length === 0)
    return EMPTY_PLUGIN;
  return {
    ...EMPTY_PLUGIN,
    extendsBundlerOptions(bundlerOptions, app) {
      const bundle = getBundlerName(app);
      if (bundle === "vite") {
        const viteReplaceAssets = createVitePlugin();
        addViteConfig(bundlerOptions, app, {
          plugins: [viteReplaceAssets(rules)]
        });
      }
      if (bundle === "webpack") {
        chainWebpack(bundlerOptions, app, (config) => {
          const webpackReplaceAssets = createWebpackPlugin();
          config.plugin(PLUGIN_NAME).use(webpackReplaceAssets, [rules]);
        });
      }
    }
  };
}
export {
  createFindPattern,
  createVitePlugin,
  createWebpackPlugin,
  isMatchUrl,
  normalizeRules,
  replaceAssetsPlugin,
  replacementAssetWithRules,
  transformAssets
};
/* istanbul ignore if -- @preserve */
