{"version":3,"file":"index.js","sources":["../../src/client/composables/setupWatermark.ts","../../src/client/helper/watermark.ts"],"sourcesContent":["import { watchImmediate } from '@vueuse/core'\nimport type { MaybeRef, Ref } from 'vue'\nimport { isRef, toValue } from 'vue'\nimport { useSiteLocaleData, withBase } from 'vuepress/client'\nimport { Watermark } from 'watermark-js-plus'\nimport type { WatermarkOptions } from '../helper/index.js'\n\nexport const setupWatermark = (\n  options: MaybeRef<WatermarkOptions>,\n  enabled: Ref<boolean>,\n): void => {\n  if (__VUEPRESS_SSR__) return\n\n  const siteData = useSiteLocaleData()\n\n  const watermark = new Watermark()\n\n  const updateWaterMark = (): void => {\n    if (toValue(enabled)) {\n      const watermarkOptions = {\n        // set default text to site title\n        content: siteData.value.title,\n        // set font color to make it readable both lightmode and darkmode\n        fontColor: '#76747f',\n        // default alpha of blind mode is 0.005 while default mode is 0.165\n        globalAlpha: toValue(options).mode === 'blind' ? 0.005 : 0.165,\n        ...toValue(options),\n      }\n\n      if (watermarkOptions.image?.startsWith('/')) {\n        watermarkOptions.image = withBase(watermarkOptions.image)\n      }\n\n      void watermark.changeOptions(watermarkOptions)\n    } else {\n      watermark.destroy()\n    }\n  }\n\n  watchImmediate([enabled, isRef(options) ? options : null], updateWaterMark, {\n    flush: 'post',\n  })\n}\n","import { isFunction, isPlainObject } from '@vuepress/helper/client'\nimport { watchImmediate } from '@vueuse/core'\nimport type {\n  App,\n  ComputedRef,\n  InjectionKey,\n  MaybeRef,\n  MaybeRefOrGetter,\n  Ref,\n} from 'vue'\nimport { computed, inject, isRef, ref, toValue } from 'vue'\nimport { usePageFrontmatter } from 'vuepress/client'\nimport type { WatermarkOptions as WatermarkRawOptions } from 'watermark-js-plus'\nimport type { WatermarkPluginFrontmatter } from '../../shared/index.js'\n\nexport type WatermarkOptions = Partial<WatermarkRawOptions>\n\nconst watermarkSymbol: InjectionKey<Ref<WatermarkOptions>> = Symbol(\n  __VUEPRESS_DEV__ ? 'watermark' : '',\n)\n\nconst watermarkOptions = ref<WatermarkOptions>({})\n\n/**\n * Define additional watermark configurations in the client-side.\n *\n * In most cases, the majority of options should be defined in Node,\n * but there are some special situations. For example,\n * it may be necessary to control different watermark opacities, font colors,\n * etc., in dark/light mode, or to pass in callbacks such as `onSuccess`, `extraDrawFunc`, and so on.\n *\n * 在客户端中定义额外的水印配置。\n *\n * 通常来说，大部分选项应该在 Node 中定义，但存在一些特殊情况。\n * 比如需要在 深色/浅色 模式下控制不同的 水印 透明度、字体颜色等，\n * 或者需要传入如 `onSuccess`、`extraDrawFunc` 等回调函数。\n *\n * @example\n * ```ts\n * import { useDarkMode } from '@vuepress/helper/client'\n * import { computed } from 'vue'\n *\n * const isDark = useDarkMode()\n *\n * const watermarkConfig = computed(() => ({\n *   fontColor: isDark.value ? '#fff' : '#000',\n *   onSuccess: () => {\n *     console.log('success')\n *   },\n * }))\n *\n * defineWatermarkConfig(watermarkConfig)\n * ```\n *\n * @param userConfig Watermark options\n *\n */\nexport const defineWatermarkConfig = (\n  userConfig: MaybeRefOrGetter<WatermarkOptions>,\n): void => {\n  if (isRef(userConfig)) {\n    watchImmediate(userConfig, (value) => {\n      watermarkOptions.value = value\n    })\n  } else if (isFunction(userConfig)) {\n    watchImmediate(computed(userConfig), (value) => {\n      watermarkOptions.value = value\n    })\n  } else {\n    watermarkOptions.value = userConfig\n  }\n}\n\nexport const useWatermarkOptions = (\n  options: MaybeRef<WatermarkOptions>,\n): ComputedRef<WatermarkOptions> => {\n  const globalOptions = inject(watermarkSymbol)!\n  const frontmatter = usePageFrontmatter<WatermarkPluginFrontmatter>()\n\n  return computed(() => {\n    const { watermark } = frontmatter.value\n\n    return {\n      ...toValue(options),\n      ...globalOptions.value,\n      ...(isPlainObject(watermark) ? watermark : {}),\n    }\n  })\n}\n\nexport const injectWatermarkConfig = (app: App): void => {\n  app.provide(watermarkSymbol, watermarkOptions)\n}\n"],"names":["setupWatermark","options","enabled","siteData","useSiteLocaleData","watermark","Watermark","updateWaterMark","toValue","watermarkOptions","withBase","watchImmediate","isRef","watermarkSymbol","ref","defineWatermarkConfig","userConfig","value","isFunction","computed","useWatermarkOptions","globalOptions","inject","frontmatter","usePageFrontmatter","isPlainObject","injectWatermarkConfig","app"],"mappings":"0UAOa,MAAAA,EAAiB,CAC5BC,EACAC,IACS,CACT,GAAI,iBAAkB,OAEtB,MAAMC,EAAWC,EAAkB,EAE7BC,EAAY,IAAIC,EAEhBC,EAAkB,IAAY,CAClC,GAAIC,EAAQN,CAAO,EAAG,CACpB,MAAMO,EAAmB,CAEvB,QAASN,EAAS,MAAM,MAExB,UAAW,UAEX,YAAaK,EAAQP,CAAO,EAAE,OAAS,QAAU,KAAQ,KACzD,GAAGO,EAAQP,CAAO,CACpB,EAEIQ,EAAiB,OAAO,WAAW,GAAG,IACxCA,EAAiB,MAAQC,EAASD,EAAiB,KAAK,GAGrDJ,EAAU,cAAcI,CAAgB,CAC/C,MACEJ,EAAU,QAAQ,CAEtB,EAEAM,EAAe,CAACT,EAASU,EAAMX,CAAO,EAAIA,EAAU,IAAI,EAAGM,EAAiB,CAC1E,MAAO,MACT,CAAC,CACH,ECzBMM,EAAuD,OAC3D,iBAAmB,YAAc,EACnC,EAEMJ,EAAmBK,EAAsB,CAAA,CAAE,EAoCpCC,EACXC,GACS,CACLJ,EAAMI,CAAU,EAClBL,EAAeK,EAAaC,GAAU,CACpCR,EAAiB,MAAQQ,CAC3B,CAAC,EACQC,EAAWF,CAAU,EAC9BL,EAAeQ,EAASH,CAAU,EAAIC,GAAU,CAC9CR,EAAiB,MAAQQ,CAC3B,CAAC,EAEDR,EAAiB,MAAQO,CAE7B,EAEaI,EACXnB,GACkC,CAClC,MAAMoB,EAAgBC,EAAOT,CAAe,EACtCU,EAAcC,EAEpB,EAAA,OAAOL,EAAS,IAAM,CACpB,KAAM,CAAE,UAAAd,CAAU,EAAIkB,EAAY,MAElC,MAAO,CACL,GAAGf,EAAQP,CAAO,EAClB,GAAGoB,EAAc,MACjB,GAAII,EAAcpB,CAAS,EAAIA,EAAY,CAAA,CAC7C,CACF,CAAC,CACH,EAEaqB,EAAyBC,GAAmB,CACvDA,EAAI,QAAQd,EAAiBJ,CAAgB,CAC/C"}