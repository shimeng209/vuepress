// src/node/theme.ts
import { sleep } from "@pengzhanbo/utils";

// src/node/autoFrontmatter/generator.ts
import { isArray, isEmptyObject as isEmptyObject2, promiseParallel, toArray } from "@pengzhanbo/utils";
import chokidar from "chokidar";
import { createFilter } from "create-filter";
import grayMatter from "gray-matter";
import jsonToYaml from "json2yaml";
import { colors as colors3, fs as fs6, hash as hash3, path as path8 } from "vuepress/utils";

// src/node/loadConfig/compiler.ts
import { promises as fsp } from "node:fs";
import path4 from "node:path";
import process2 from "node:process";
import { pathToFileURL } from "node:url";
import { build } from "esbuild";
import { importFileDefault } from "vuepress/utils";

// src/node/utils/constants.ts
var THEME_NAME = "vuepress-theme-plume";

// src/node/utils/createFsCache.ts
import fs from "node:fs/promises";
import path from "node:path";
import { hash } from "vuepress/utils";
var CACHE_BASE = "markdown";
function createFsCache(app, name) {
  const filepath = app.dir.cache(`${CACHE_BASE}/${name}.json`);
  const cache4 = { hash: "", data: null };
  const read = async () => {
    if (!cache4.data) {
      try {
        const content = await fs.readFile(filepath, "utf-8");
        if (content) {
          const res = JSON.parse(content);
          cache4.data = res.data ?? null;
          cache4.hash = hash(res.hash || "");
        }
      } catch {
      }
    }
    return cache4.data;
  };
  let timer = null;
  const write = async (data) => {
    const currentHash = hash(data);
    if (cache4.hash && currentHash === cache4.hash)
      return;
    cache4.data = data;
    cache4.hash = currentHash;
    timer && clearTimeout(timer);
    timer = setTimeout(async () => {
      await fs.mkdir(path.dirname(filepath), { recursive: true });
      await fs.writeFile(filepath, JSON.stringify(cache4), "utf-8");
    }, 300);
  };
  return {
    get hash() {
      return cache4.hash;
    },
    get data() {
      return cache4.data;
    },
    read,
    write
  };
}

// src/node/utils/hash.ts
import { createHash } from "node:crypto";
import { customAlphabet } from "nanoid";
var hash2 = (content) => createHash("md5").update(content).digest("hex");
var nanoid = customAlphabet("0123456789abcdefghijklmnopqrstuvwxyz", 8);

// src/node/utils/interopDefault.ts
async function interopDefault(m) {
  const resolved = await m;
  return resolved.default || resolved;
}

// src/node/utils/logger.ts
import { Logger } from "@vuepress/helper";
import { colors } from "vuepress/utils";
var logger = new Logger(THEME_NAME);
var Perf = class {
  isDebug = false;
  collect = {};
  init(isDebug = false) {
    this.isDebug = isDebug;
  }
  mark(mark) {
    this.collect[mark] = performance.now();
  }
  log(mark) {
    const startTime = this.collect[mark];
    if (!this.isDebug || !startTime)
      return;
    logger.info("[perf spent time] ", `${colors.green(mark)}: ${colors.cyan(`${(performance.now() - startTime).toFixed(2)}ms`)}`);
  }
};
var perf = new Perf();

// src/node/utils/package.ts
import process from "node:process";
import { fs as fs2, path as path3 } from "vuepress/utils";

// src/node/utils/path.ts
import { ensureEndingSlash, ensureLeadingSlash, isLinkAbsolute, isLinkWithProtocol } from "@vuepress/helper";
import { getDirname, path as path2 } from "vuepress/utils";
var __dirname = getDirname(import.meta.url);
var resolve = (...args) => path2.resolve(__dirname, "../", ...args);
var templates = (url) => resolve("../templates", url);
var RE_SLASH = /(\\|\/)+/g;
function normalizePath(path10) {
  return path10.replace(RE_SLASH, "/");
}
function pathJoin(...args) {
  return normalizePath(path2.join(...args));
}
function normalizeLink(base, link = "") {
  return isLinkAbsolute(link) || isLinkWithProtocol(link) ? link : ensureLeadingSlash(normalizePath(`${base}/${link}/`));
}
var RE_START_END_SLASH = /^\/|\/$/g;
function getCurrentDirname(basePath, filepath) {
  const dirList = normalizePath(basePath || path2.dirname(filepath)).replace(RE_START_END_SLASH, "").split("/");
  return dirList.length > 0 ? dirList[dirList.length - 1] : "";
}
function withBase(path10 = "", base = "/") {
  path10 = ensureEndingSlash(ensureLeadingSlash(path10));
  if (path10.startsWith(base))
    return normalizePath(path10);
  return normalizePath(`${base}${path10}`);
}

// src/node/utils/package.ts
function readJsonFileAsync(filePath) {
  try {
    const content = fs2.readFileSync(filePath, "utf-8");
    return JSON.parse(content);
  } catch {
  }
  return {};
}
function getPackage() {
  return readJsonFileAsync(path3.join(process.cwd(), "package.json"));
}
function getThemePackage() {
  return readJsonFileAsync(resolve("../package.json"));
}

// src/node/utils/resolveContent.ts
function resolveContent(app, { name, content, before, after }) {
  content = `${before ? `${before}
` : ""}export const ${name} = ${JSON.stringify(content)}${after ? `
${after}` : ""}`;
  if (app.env.isDev) {
    const func = `update${name[0].toUpperCase()}${name.slice(1)}`;
    content += `

if (import.meta.webpackHot) {
  import.meta.webpackHot.accept()
  if (__VUE_HMR_RUNTIME__.${func}) {
    __VUE_HMR_RUNTIME__.${func}(${name})
  }
}

if (import.meta.hot) {
  import.meta.hot.accept(({ ${name} }) => {
    __VUE_HMR_RUNTIME__.${func}(${name})
  })
}
`;
  }
  return content;
}

// src/node/utils/translate.ts
import { isEmptyObject } from "@pengzhanbo/utils";
var lang = "en";
function setTranslateLang(current) {
  if (["zh-CN", "zh", "zh-Hans", "zh-Hant"].includes(current)) {
    lang = "zh";
  } else {
    lang = "en";
  }
}
function createTranslate(locales) {
  return function t5(key, data) {
    const resolved = locales[lang][key];
    if (!resolved)
      return key;
    if (data && !isEmptyObject(data)) {
      return resolved.replace(/\{\{\s*(\w+)\s*\}\}/g, (_, key2) => data[key2] || _);
    }
    return resolved;
  };
}

// src/node/utils/writeTemp.ts
var contentHash = /* @__PURE__ */ new Map();
async function writeTemp(app, filepath, content) {
  const currentHash = hash2(content);
  if (!contentHash.has(filepath) || contentHash.get(filepath) !== currentHash) {
    contentHash.set(filepath, currentHash);
    await app.writeTemp(filepath, content);
  }
}

// src/node/loadConfig/compiler.ts
async function compiler(configPath) {
  if (!configPath) {
    return { config: {}, dependencies: [] };
  }
  const dirnameVarName = "__vite_injected_original_dirname";
  const filenameVarName = "__vite_injected_original_filename";
  const importMetaUrlVarName = "__vite_injected_original_import_meta_url";
  const result = await build({
    absWorkingDir: process2.cwd(),
    entryPoints: [configPath],
    outfile: "out.js",
    write: false,
    target: [`node${process2.versions.node}`],
    platform: "node",
    bundle: true,
    format: "esm",
    mainFields: ["main"],
    sourcemap: "inline",
    metafile: true,
    define: {
      "__dirname": dirnameVarName,
      "__filename": filenameVarName,
      "import.meta.url": importMetaUrlVarName,
      "import.meta.dirname": dirnameVarName,
      "import.meta.filename": filenameVarName
    },
    plugins: [
      {
        name: "externalize-deps",
        setup(build2) {
          build2.onResolve({ filter: /.*/ }, ({ path: id }) => {
            if (id[0] !== "." && !path4.isAbsolute(id)) {
              return { external: true };
            }
            return null;
          });
        }
      },
      {
        name: "inject-file-scope-variables",
        setup(build2) {
          build2.onLoad({ filter: /\.[cm]?[jt]s$/ }, async (args) => {
            const contents = await fsp.readFile(args.path, "utf-8");
            const injectValues = `const ${dirnameVarName} = ${JSON.stringify(
              path4.dirname(args.path)
            )};const ${filenameVarName} = ${JSON.stringify(args.path)};const ${importMetaUrlVarName} = ${JSON.stringify(
              pathToFileURL(args.path).href
            )};`;
            return {
              loader: args.path.endsWith("ts") ? "ts" : "js",
              contents: injectValues + contents
            };
          });
        }
      }
    ]
  });
  const { text } = result.outputFiles[0];
  const tempFilePath = `${configPath}.${hash2(text)}.mjs`;
  let config;
  try {
    await fsp.writeFile(tempFilePath, text);
    config = await importFileDefault(tempFilePath);
  } finally {
    await fsp.rm(tempFilePath);
  }
  return {
    config,
    dependencies: Object.keys(result.metafile?.inputs ?? {})
  };
}

// src/node/loadConfig/findConfigPath.ts
import fs3, { constants, promises as fsp2 } from "node:fs";
import { resolve as resolve2 } from "node:path";
import process3 from "node:process";
import { colors as colors2 } from "vuepress/utils";
var CONFIG_FILE_NAME = "plume.config";
var extensions = ["ts", "js", "mjs", "cjs", "mts", "cts"];
async function findConfigPath(app, configPath) {
  const cwd = process3.cwd();
  const source = app.dir.source(".vuepress");
  const paths = [];
  if (configPath) {
    const path10 = resolve2(cwd, configPath);
    if (existsSync(path10) && (await fsp2.stat(path10)).isFile()) {
      return path10;
    }
  }
  extensions.forEach(
    (ext) => paths.push(
      resolve2(cwd, `${source}/${CONFIG_FILE_NAME}.${ext}`),
      resolve2(cwd, `./${CONFIG_FILE_NAME}.${ext}`),
      resolve2(cwd, `./.vuepress/${CONFIG_FILE_NAME}.${ext}`)
    )
  );
  let current;
  for (const path10 of paths) {
    if (existsSync(path10) && (await fsp2.stat(path10)).isFile()) {
      current = path10;
      break;
    }
  }
  if (configPath && current) {
    logger.warn(`Can not find config file: ${colors2.gray(configPath)}
Use config file: ${colors2.gray(current)}`);
  }
  return current;
}
function existsSync(fp) {
  try {
    fs3.accessSync(fp, constants.R_OK);
    return true;
  } catch {
    return false;
  }
}

// src/node/loadConfig/loader.ts
import process4 from "node:process";
import { deepMerge } from "@pengzhanbo/utils";
import { watch } from "chokidar";

// src/node/config/initThemeOptions.ts
import { hasOwn, uniq } from "@pengzhanbo/utils";
import { entries, fromEntries, getFullLocaleConfig, isPlainObject } from "@vuepress/helper";

// src/node/locales/de.ts
var deLocale = {
  selectLanguageName: "Deutsch",
  selectLanguageText: "Sprache ausw\xE4hlen",
  appearanceText: "Erscheinungsbild",
  lightModeSwitchTitle: "Zu hellem Thema wechseln",
  darkModeSwitchTitle: "Zu dunklem Thema wechseln",
  outlineLabel: "Inhalt dieser Seite",
  returnToTopLabel: "Zur\xFCck nach oben",
  editLinkText: "Diese Seite bearbeiten",
  contributorsText: "Mitwirkende",
  prevPageLabel: "Vorherige Seite",
  nextPageLabel: "N\xE4chste Seite",
  lastUpdatedText: "Zuletzt aktualisiert am",
  changelogText: "\xC4nderungsprotokoll",
  changelogOnText: "am",
  changelogButtonText: "Alle \xC4nderungen anzeigen",
  copyrightText: "Alle Rechte vorbehalten",
  copyrightAuthorText: "Urheberrecht liegt bei:",
  copyrightCreationOriginalText: "Originalartikel:",
  copyrightCreationTranslateText: "\xDCbersetzt aus:",
  copyrightCreationReprintText: "Nachdruck von:",
  copyrightLicenseText: "Lizenz:",
  notFound: {
    code: "404",
    title: "Seite nicht gefunden",
    quote: "Aber wenn du deine Richtung nicht \xE4nderst und weiter suchst, k\xF6nntest du schlie\xDFlich dorthin gelangen, wohin du gehen willst.",
    linkText: "Zur Startseite"
  },
  homeText: "Startseite",
  blogText: "Blog",
  tagText: "Tag",
  archiveText: "Archiv",
  categoryText: "Kategorie",
  archiveTotalText: "{count} Beitr\xE4ge",
  encryptButtonText: "Best\xE4tigen",
  encryptPlaceholder: "Bitte Passwort eingeben",
  encryptGlobalText: "Diese Website ist nur mit Passwort zug\xE4nglich",
  encryptPageText: "Diese Seite ist nur mit Passwort zug\xE4nglich",
  footer: {
    message: 'Unterst\xFCtzt von <a target="_blank" href="https://v2.vuepress.vuejs.org/">VuePress</a> & <a target="_blank" href="https://theme-plume.vuejs.press">vuepress-theme-plume</a>'
  }
};
var dePresetLocale = {
  // ------ copyright license ------
  "CC0": "CC0 1.0 Universell",
  "CC-BY-4.0": "Namensnennung 4.0 International",
  "CC-BY-NC-4.0": "Namensnennung-Nicht kommerziell 4.0 International",
  "CC-BY-NC-SA-4.0": "Namensnennung-Nicht kommerziell-Weitergabe unter gleichen Bedingungen 4.0 International",
  "CC-BY-NC-ND-4.0": "Namensnennung-Nicht kommerziell-Keine Bearbeitung 4.0 International",
  "CC-BY-ND-4.0": "Namensnennung-Keine Bearbeitung 4.0 International",
  "CC-BY-SA-4.0": "Namensnennung-Weitergabe unter gleichen Bedingungen 4.0 International"
};

// src/node/locales/en.ts
var enLocale = {
  selectLanguageName: "English",
  selectLanguageText: "Languages",
  appearanceText: "Appearance",
  lightModeSwitchTitle: "Switch to light theme",
  darkModeSwitchTitle: "Switch to dark theme",
  editLinkText: "Edit this page",
  contributorsText: "Contributors",
  lastUpdatedText: "Last Updated",
  changelogText: "Changelog",
  changelogOnText: "On",
  changelogButtonText: "View All Changelog",
  copyrightText: "Copyright",
  copyrightAuthorText: "Copyright Ownership:",
  copyrightCreationOriginalText: "This article link:",
  copyrightCreationTranslateText: "This article is translated from:",
  copyrightCreationReprintText: "This article is reprint from:",
  copyrightLicenseText: "License under:",
  encryptButtonText: "Confirm",
  encryptPlaceholder: "Enter password",
  encryptGlobalText: "Only password can access this site",
  encryptPageText: "Only password can access this page",
  homeText: "Home",
  blogText: "Blog",
  tagText: "Tags",
  archiveText: "Archives",
  categoryText: "Categories",
  archiveTotalText: "{count} articles",
  footer: {
    message: 'Powered by <a target="_blank" href="https://v2.vuepress.vuejs.org/">VuePress</a> & <a target="_blank" href="https://theme-plume.vuejs.press">vuepress-theme-plume</a>'
  }
};
var enPresetLocale = {
  // ------ copyright license ------
  "CC0": "CC0 1.0 Universal",
  "CC-BY-4.0": "Attribution 4.0 International",
  "CC-BY-NC-4.0": "Attribution-NonCommercial 4.0 International",
  "CC-BY-NC-SA-4.0": "Attribution-NonCommercial-ShareAlike 4.0 International",
  "CC-BY-NC-ND-4.0": "Attribution-NonCommercial-NoDerivatives 4.0 International",
  "CC-BY-ND-4.0": "Attribution-NoDerivatives 4.0 International",
  "CC-BY-SA-4.0": "Attribution-ShareAlike 4.0 International"
};

// src/node/locales/fr.ts
var frLocale = {
  selectLanguageName: "Fran\xE7ais",
  selectLanguageText: "Choisir la langue",
  appearanceText: "Apparence",
  lightModeSwitchTitle: "Passer au th\xE8me clair",
  darkModeSwitchTitle: "Passer au th\xE8me sombre",
  outlineLabel: "Contenu de cette page",
  returnToTopLabel: "Retour en haut",
  editLinkText: "Modifier cette page",
  contributorsText: "Contributeurs",
  prevPageLabel: "Page pr\xE9c\xE9dente",
  nextPageLabel: "Page suivante",
  lastUpdatedText: "Derni\xE8re mise \xE0 jour",
  changelogText: "Historique des changements",
  changelogOnText: "le",
  changelogButtonText: "Voir tout l'historique des changements",
  copyrightText: "Tous droits r\xE9serv\xE9s",
  copyrightAuthorText: "Copyright appartenant \xE0 :",
  copyrightCreationOriginalText: "Lien de l'article :",
  copyrightCreationTranslateText: "Traduit de :",
  copyrightCreationReprintText: "Reproduit de :",
  copyrightLicenseText: "Licence :",
  notFound: {
    code: "404",
    title: "Page non trouv\xE9e",
    quote: "Mais si tu ne changes pas de direction et que tu continues \xE0 chercher, tu finiras par arriver \xE0 destination.",
    linkText: "Retour \xE0 l'accueil"
  },
  homeText: "Accueil",
  blogText: "Blog",
  tagText: "\xC9tiquette",
  archiveText: "Archives",
  categoryText: "Cat\xE9gorie",
  archiveTotalText: "{count} articles",
  encryptButtonText: "Confirmer",
  encryptPlaceholder: "Veuillez entrer le mot de passe",
  encryptGlobalText: "Ce site n'est accessible qu'avec un mot de passe",
  encryptPageText: "Cette page n'est accessible qu'avec un mot de passe",
  footer: {
    message: 'Propuls\xE9 par <a target="_blank" href="https://v2.vuepress.vuejs.org/">VuePress</a> & <a target="_blank" href="https://theme-plume.vuejs.press">vuepress-theme-plume</a>'
  }
};
var frPresetLocale = {
  // ------ copyright license ------
  "CC0": "CC0 1.0 Universel",
  "CC-BY-4.0": "Attribution 4.0 International",
  "CC-BY-NC-4.0": "Attribution-Pas d'Utilisation Commerciale 4.0 International",
  "CC-BY-NC-SA-4.0": "Attribution-Pas d'Utilisation Commerciale-Partage dans les M\xEAmes Conditions 4.0 International",
  "CC-BY-NC-ND-4.0": "Attribution-Pas d'Utilisation Commerciale-Pas de Modification 4.0 International",
  "CC-BY-ND-4.0": "Attribution-Pas de Modification 4.0 International",
  "CC-BY-SA-4.0": "Attribution-Partage dans les M\xEAmes Conditions 4.0 International"
};

// src/node/locales/ja.ts
var jaLocale = {
  selectLanguageName: "\u65E5\u672C\u8A9E",
  selectLanguageText: "\u8A00\u8A9E\u3092\u9078\u629E",
  appearanceText: "\u5916\u89B3",
  lightModeSwitchTitle: "\u30E9\u30A4\u30C8\u30E2\u30FC\u30C9\u306B\u5207\u308A\u66FF\u3048",
  darkModeSwitchTitle: "\u30C0\u30FC\u30AF\u30E2\u30FC\u30C9\u306B\u5207\u308A\u66FF\u3048",
  outlineLabel: "\u3053\u306E\u30DA\u30FC\u30B8\u306E\u5185\u5BB9",
  returnToTopLabel: "\u30C8\u30C3\u30D7\u306B\u623B\u308B",
  editLinkText: "\u3053\u306E\u30DA\u30FC\u30B8\u3092\u7DE8\u96C6",
  contributorsText: "\u8CA2\u732E\u8005",
  prevPageLabel: "\u524D\u306E\u30DA\u30FC\u30B8",
  nextPageLabel: "\u6B21\u306E\u30DA\u30FC\u30B8",
  lastUpdatedText: "\u6700\u7D42\u66F4\u65B0\u65E5",
  changelogText: "\u5909\u66F4\u5C65\u6B74",
  changelogOnText: "\u306B",
  changelogButtonText: "\u3059\u3079\u3066\u306E\u5909\u66F4\u5C65\u6B74\u3092\u898B\u308B",
  copyrightText: "\u8457\u4F5C\u6A29",
  copyrightAuthorText: "\u8457\u4F5C\u6A29\u8005\uFF1A",
  copyrightCreationOriginalText: "\u672C\u6587\u30EA\u30F3\u30AF\uFF1A",
  copyrightCreationTranslateText: "\u672C\u6587\u306E\u7FFB\u8A33\u5143\uFF1A",
  copyrightCreationReprintText: "\u672C\u6587\u306E\u8EE2\u8F09\u5143\uFF1A",
  copyrightLicenseText: "\u30E9\u30A4\u30BB\u30F3\u30B9\uFF1A",
  notFound: {
    code: "404",
    title: "\u30DA\u30FC\u30B8\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093",
    quote: "\u3057\u304B\u3057\u3001\u65B9\u5411\u3092\u5909\u3048\u305A\u306B\u63A2\u3057\u7D9A\u3051\u308C\u3070\u3001\u6700\u7D42\u7684\u306B\u306F\u884C\u304D\u305F\u3044\u5834\u6240\u306B\u305F\u3069\u308A\u7740\u304F\u304B\u3082\u3057\u308C\u307E\u305B\u3093\u3002",
    linkText: "\u30DB\u30FC\u30E0\u306B\u623B\u308B"
  },
  homeText: "\u30DB\u30FC\u30E0",
  blogText: "\u30D6\u30ED\u30B0",
  tagText: "\u30BF\u30B0",
  archiveText: "\u30A2\u30FC\u30AB\u30A4\u30D6",
  categoryText: "\u30AB\u30C6\u30B4\u30EA\u30FC",
  archiveTotalText: "{count} \u4EF6",
  encryptButtonText: "\u78BA\u8A8D",
  encryptPlaceholder: "\u30D1\u30B9\u30EF\u30FC\u30C9\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044",
  encryptGlobalText: "\u3053\u306E\u30B5\u30A4\u30C8\u306F\u30D1\u30B9\u30EF\u30FC\u30C9\u3067\u306E\u307F\u30A2\u30AF\u30BB\u30B9\u53EF\u80FD\u3067\u3059",
  encryptPageText: "\u3053\u306E\u30DA\u30FC\u30B8\u306F\u30D1\u30B9\u30EF\u30FC\u30C9\u3067\u306E\u307F\u30A2\u30AF\u30BB\u30B9\u53EF\u80FD\u3067\u3059",
  footer: {
    message: '<a target="_blank" href="https://v2.vuepress.vuejs.org/">VuePress</a> & <a target="_blank" href="https://theme-plume.vuejs.press">vuepress-theme-plume</a> \u306B\u3088\u3063\u3066\u63D0\u4F9B\u3055\u308C\u3066\u3044\u307E\u3059'
  }
};
var jaPresetLocale = {
  // ------ copyright license ------
  "CC0": "CC0 1.0 \u30D1\u30D6\u30EA\u30C3\u30AF\u30C9\u30E1\u30A4\u30F3",
  "CC-BY-4.0": "\u8868\u793A 4.0 \u56FD\u969B",
  "CC-BY-NC-4.0": "\u8868\u793A-\u975E\u55B6\u5229 4.0 \u56FD\u969B",
  "CC-BY-NC-SA-4.0": "\u8868\u793A-\u975E\u55B6\u5229-\u7D99\u627F 4.0 \u56FD\u969B",
  "CC-BY-NC-ND-4.0": "\u8868\u793A-\u975E\u55B6\u5229-\u6539\u5909\u7981\u6B62 4.0 \u56FD\u969B",
  "CC-BY-ND-4.0": "\u8868\u793A-\u6539\u5909\u7981\u6B62 4.0 \u56FD\u969B",
  "CC-BY-SA-4.0": "\u8868\u793A-\u7D99\u627F 4.0 \u56FD\u969B"
};

// src/node/locales/ru.ts
var ruLocale = {
  selectLanguageName: "\u0420\u0443\u0441\u0441\u043A\u0438\u0439",
  selectLanguageText: "\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u044F\u0437\u044B\u043A",
  appearanceText: "\u0412\u043D\u0435\u0448\u043D\u0438\u0439 \u0432\u0438\u0434",
  lightModeSwitchTitle: "\u041F\u0435\u0440\u0435\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u043D\u0430 \u0441\u0432\u0435\u0442\u043B\u0443\u044E \u0442\u0435\u043C\u0443",
  darkModeSwitchTitle: "\u041F\u0435\u0440\u0435\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u043D\u0430 \u0442\u0435\u043C\u043D\u0443\u044E \u0442\u0435\u043C\u0443",
  outlineLabel: "\u0421\u043E\u0434\u0435\u0440\u0436\u0430\u043D\u0438\u0435 \u0441\u0442\u0440\u0430\u043D\u0438\u0446\u044B",
  returnToTopLabel: "\u0412\u0435\u0440\u043D\u0443\u0442\u044C\u0441\u044F \u043D\u0430\u0432\u0435\u0440\u0445",
  editLinkText: "\u0420\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0441\u0442\u0440\u0430\u043D\u0438\u0446\u0443",
  contributorsText: "\u0410\u0432\u0442\u043E\u0440\u044B",
  prevPageLabel: "\u041F\u0440\u0435\u0434\u044B\u0434\u0443\u0449\u0430\u044F \u0441\u0442\u0440\u0430\u043D\u0438\u0446\u0430",
  nextPageLabel: "\u0421\u043B\u0435\u0434\u0443\u044E\u0449\u0430\u044F \u0441\u0442\u0440\u0430\u043D\u0438\u0446\u0430",
  lastUpdatedText: "\u041F\u043E\u0441\u043B\u0435\u0434\u043D\u0435\u0435 \u043E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u0438\u0435",
  changelogText: "\u0418\u0441\u0442\u043E\u0440\u0438\u044F \u0438\u0437\u043C\u0435\u043D\u0435\u043D\u0438\u0439",
  changelogOnText: "\u043E\u0442",
  changelogButtonText: "\u041F\u043E\u0441\u043C\u043E\u0442\u0440\u0435\u0442\u044C \u0432\u0441\u0435 \u0438\u0437\u043C\u0435\u043D\u0435\u043D\u0438\u044F",
  copyrightText: "\u0412\u0441\u0435 \u043F\u0440\u0430\u0432\u0430 \u0437\u0430\u0449\u0438\u0449\u0435\u043D\u044B",
  copyrightAuthorText: "\u0410\u0432\u0442\u043E\u0440\u0441\u043A\u0438\u0435 \u043F\u0440\u0430\u0432\u0430 \u043F\u0440\u0438\u043D\u0430\u0434\u043B\u0435\u0436\u0430\u0442:",
  copyrightCreationOriginalText: "\u0421\u0441\u044B\u043B\u043A\u0430 \u043D\u0430 \u0441\u0442\u0430\u0442\u044C\u044E:",
  copyrightCreationTranslateText: "\u041F\u0435\u0440\u0435\u0432\u043E\u0434 \u0441\u0442\u0430\u0442\u044C\u0438:",
  copyrightCreationReprintText: "\u041F\u0435\u0440\u0435\u043F\u0435\u0447\u0430\u0442\u0430\u043D\u043E \u0438\u0437:",
  copyrightLicenseText: "\u041B\u0438\u0446\u0435\u043D\u0437\u0438\u044F:",
  notFound: {
    code: "404",
    title: "\u0421\u0442\u0440\u0430\u043D\u0438\u0446\u0430 \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D\u0430",
    quote: "\u041D\u043E \u0435\u0441\u043B\u0438 \u0432\u044B \u043D\u0435 \u043C\u0435\u043D\u044F\u0435\u0442\u0435 \u043A\u0443\u0440\u0441 \u0438 \u043F\u0440\u043E\u0434\u043E\u043B\u0436\u0430\u0435\u0442\u0435 \u0438\u0441\u043A\u0430\u0442\u044C, \u0432 \u043A\u043E\u043D\u0435\u0447\u043D\u043E\u043C \u0438\u0442\u043E\u0433\u0435 \u0432\u044B \u043C\u043E\u0436\u0435\u0442\u0435 \u0434\u043E\u0431\u0440\u0430\u0442\u044C\u0441\u044F \u0434\u043E \u043C\u0435\u0441\u0442\u0430 \u043D\u0430\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u044F.",
    linkText: "\u0412\u0435\u0440\u043D\u0443\u0442\u044C\u0441\u044F \u043D\u0430 \u0433\u043B\u0430\u0432\u043D\u0443\u044E"
  },
  homeText: "\u0413\u043B\u0430\u0432\u043D\u0430\u044F",
  blogText: "\u0411\u043B\u043E\u0433",
  tagText: "\u0422\u0435\u0433\u0438",
  archiveText: "\u0410\u0440\u0445\u0438\u0432",
  categoryText: "\u041A\u0430\u0442\u0435\u0433\u043E\u0440\u0438\u0438",
  archiveTotalText: "{count} \u0441\u0442\u0430\u0442\u0435\u0439",
  encryptButtonText: "\u041F\u043E\u0434\u0442\u0432\u0435\u0440\u0434\u0438\u0442\u044C",
  encryptPlaceholder: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043F\u0430\u0440\u043E\u043B\u044C",
  encryptGlobalText: "\u0414\u043E\u0441\u0442\u0443\u043F \u043A \u0441\u0430\u0439\u0442\u0443 \u0442\u043E\u043B\u044C\u043A\u043E \u043F\u043E \u043F\u0430\u0440\u043E\u043B\u044E",
  encryptPageText: "\u0414\u043E\u0441\u0442\u0443\u043F \u043A \u0441\u0442\u0440\u0430\u043D\u0438\u0446\u0435 \u0442\u043E\u043B\u044C\u043A\u043E \u043F\u043E \u043F\u0430\u0440\u043E\u043B\u044E",
  footer: {
    message: '\u0420\u0430\u0431\u043E\u0442\u0430\u0435\u0442 \u043D\u0430 <a target="_blank" href="https://v2.vuepress.vuejs.org/">VuePress</a> & <a target="_blank" href="https://theme-plume.vuejs.press">vuepress-theme-plume</a>'
  }
};
var ruPresetLocale = {
  // ------ copyright license ------
  "CC0": "CC0 1.0 \u0423\u043D\u0438\u0432\u0435\u0440\u0441\u0430\u043B\u044C\u043D\u0430\u044F",
  "CC-BY-4.0": "\u0410\u0442\u0440\u0438\u0431\u0443\u0446\u0438\u044F 4.0 \u041C\u0435\u0436\u0434\u0443\u043D\u0430\u0440\u043E\u0434\u043D\u044B\u0439",
  "CC-BY-NC-4.0": "\u0410\u0442\u0440\u0438\u0431\u0443\u0446\u0438\u044F-\u041D\u0435\u043A\u043E\u043C\u043C\u0435\u0440\u0447\u0435\u0441\u043A\u043E\u0435 4.0 \u041C\u0435\u0436\u0434\u0443\u043D\u0430\u0440\u043E\u0434\u043D\u044B\u0439",
  "CC-BY-NC-SA-4.0": "\u0410\u0442\u0440\u0438\u0431\u0443\u0446\u0438\u044F-\u041D\u0435\u043A\u043E\u043C\u043C\u0435\u0440\u0447\u0435\u0441\u043A\u043E\u0435-\u0421 \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u0438\u0435\u043C \u0443\u0441\u043B\u043E\u0432\u0438\u0439 4.0 \u041C\u0435\u0436\u0434\u0443\u043D\u0430\u0440\u043E\u0434\u043D\u044B\u0439",
  "CC-BY-NC-ND-4.0": "\u0410\u0442\u0440\u0438\u0431\u0443\u0446\u0438\u044F-\u041D\u0435\u043A\u043E\u043C\u043C\u0435\u0440\u0447\u0435\u0441\u043A\u043E\u0435-\u0411\u0435\u0437 \u043F\u0440\u043E\u0438\u0437\u0432\u043E\u0434\u043D\u044B\u0445 4.0 \u041C\u0435\u0436\u0434\u0443\u043D\u0430\u0440\u043E\u0434\u043D\u044B\u0439",
  "CC-BY-ND-4.0": "\u0410\u0442\u0440\u0438\u0431\u0443\u0446\u0438\u044F-\u0411\u0435\u0437 \u043F\u0440\u043E\u0438\u0437\u0432\u043E\u0434\u043D\u044B\u0445 4.0 \u041C\u0435\u0436\u0434\u0443\u043D\u0430\u0440\u043E\u0434\u043D\u044B\u0439",
  "CC-BY-SA-4.0": "\u0410\u0442\u0440\u0438\u0431\u0443\u0446\u0438\u044F-\u0421 \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u0438\u0435\u043C \u0443\u0441\u043B\u043E\u0432\u0438\u0439 4.0 \u041C\u0435\u0436\u0434\u0443\u043D\u0430\u0440\u043E\u0434\u043D\u044B\u0439"
};

// src/node/locales/zh-tw.ts
var zhTwLocale = {
  selectLanguageName: "\u7E41\u9AD4\u4E2D\u6587",
  selectLanguageText: "\u9078\u64C7\u8A9E\u8A00",
  appearanceText: "\u5916\u89C0",
  lightModeSwitchTitle: "\u5207\u63DB\u70BA\u6DFA\u8272\u4E3B\u984C",
  darkModeSwitchTitle: "\u5207\u63DB\u70BA\u6DF1\u8272\u4E3B\u984C",
  outlineLabel: "\u6B64\u9801\u5167\u5BB9",
  returnToTopLabel: "\u8FD4\u56DE\u9802\u90E8",
  editLinkText: "\u7DE8\u8F2F\u6B64\u9801",
  contributorsText: "\u8CA2\u737B\u8005",
  prevPageLabel: "\u4E0A\u4E00\u9801",
  nextPageLabel: "\u4E0B\u4E00\u9801",
  lastUpdatedText: "\u6700\u5F8C\u66F4\u65B0\u65BC",
  changelogText: "\u8B8A\u66F4\u6B77\u53F2",
  changelogOnText: "\u65BC",
  changelogButtonText: "\u67E5\u770B\u5168\u90E8\u8B8A\u66F4\u6B77\u53F2",
  copyrightText: "\u7248\u6B0A\u6240\u6709",
  copyrightAuthorText: "\u7248\u6B0A\u6B78\u5C6C\uFF1A",
  copyrightCreationOriginalText: "\u672C\u6587\u9023\u7D50\uFF1A",
  copyrightCreationTranslateText: "\u672C\u6587\u7FFB\u8B6F\u81EA\uFF1A",
  copyrightCreationReprintText: "\u672C\u6587\u8F49\u8F09\u81EA\uFF1A",
  copyrightLicenseText: "\u8A31\u53EF\u8B49\uFF1A",
  notFound: {
    code: "404",
    title: "\u9801\u9762\u672A\u627E\u5230",
    quote: "\u4F46\u662F\uFF0C\u5982\u679C\u4F60\u4E0D\u6539\u8B8A\u65B9\u5411\uFF0C\u4E26\u4E14\u4E00\u76F4\u5C0B\u627E\uFF0C\u6700\u7D42\u53EF\u80FD\u6703\u5230\u9054\u4F60\u8981\u53BB\u7684\u5730\u65B9\u3002",
    linkText: "\u8FD4\u56DE\u9996\u9801"
  },
  homeText: "\u9996\u9801",
  blogText: "\u535A\u5BA2",
  tagText: "\u6A19\u7C64",
  archiveText: "\u6B78\u6A94",
  categoryText: "\u5206\u985E",
  archiveTotalText: "{count} \u7BC7",
  encryptButtonText: "\u78BA\u8A8D",
  encryptPlaceholder: "\u8ACB\u8F38\u5165\u5BC6\u78BC",
  encryptGlobalText: "\u672C\u7AD9\u53EA\u5141\u8A31\u5BC6\u78BC\u8A2A\u554F",
  encryptPageText: "\u672C\u9801\u9762\u53EA\u5141\u8A31\u5BC6\u78BC\u8A2A\u554F",
  footer: {
    message: 'Powered by <a target="_blank" href="https://v2.vuepress.vuejs.org/">VuePress</a> & <a target="_blank" href="https://theme-plume.vuejs.press">vuepress-theme-plume</a>'
  }
};
var zhTwPresetLocale = {
  // ------ copyright license ------
  "CC0": "CC0 1.0 \u901A\u7528",
  "CC-BY-4.0": "\u7F72\u540D 4.0 \u570B\u969B",
  "CC-BY-NC-4.0": "\u7F72\u540D-\u975E\u5546\u696D\u6027 4.0 \u570B\u969B",
  "CC-BY-NC-SA-4.0": "\u7F72\u540D-\u975E\u5546\u696D\u6027-\u76F8\u540C\u65B9\u5F0F\u5171\u4EAB 4.0 \u570B\u969B",
  "CC-BY-NC-ND-4.0": "\u7F72\u540D-\u975E\u5546\u696D\u6027-\u7981\u6B62\u6F14\u7E79 4.0 \u570B\u969B",
  "CC-BY-ND-4.0": "\u7F72\u540D-\u7981\u6B62\u6F14\u7E79 4.0 \u570B\u969B",
  "CC-BY-SA-4.0": "\u7F72\u540D-\u76F8\u540C\u65B9\u5F0F\u5171\u4EAB 4.0 \u570B\u969B"
};

// src/node/locales/zh.ts
var zhLocale = {
  selectLanguageName: "\u7B80\u4F53\u4E2D\u6587",
  selectLanguageText: "\u9009\u62E9\u8BED\u8A00",
  appearanceText: "\u5916\u89C2",
  lightModeSwitchTitle: "\u5207\u6362\u4E3A\u6D45\u8272\u4E3B\u9898",
  darkModeSwitchTitle: "\u5207\u6362\u4E3A\u6DF1\u8272\u4E3B\u9898",
  outlineLabel: "\u6B64\u9875\u5185\u5BB9",
  returnToTopLabel: "\u8FD4\u56DE\u9876\u90E8",
  editLinkText: "\u7F16\u8F91\u6B64\u9875",
  contributorsText: "\u8D21\u732E\u8005",
  prevPageLabel: "\u4E0A\u4E00\u9875",
  nextPageLabel: "\u4E0B\u4E00\u9875",
  lastUpdatedText: "\u6700\u540E\u66F4\u65B0\u4E8E",
  changelogText: "\u53D8\u66F4\u5386\u53F2",
  changelogOnText: "\u4E8E",
  changelogButtonText: "\u67E5\u770B\u5168\u90E8\u53D8\u66F4\u5386\u53F2",
  copyrightText: "\u7248\u6743\u6240\u6709",
  copyrightAuthorText: "\u7248\u6743\u5F52\u5C5E\uFF1A",
  copyrightCreationOriginalText: "\u672C\u6587\u94FE\u63A5\uFF1A",
  copyrightCreationTranslateText: "\u672C\u6587\u7FFB\u8BD1\u81EA\uFF1A",
  copyrightCreationReprintText: "\u672C\u6587\u8F6C\u8F7D\u81EA\uFF1A",
  copyrightLicenseText: "\u8BB8\u53EF\u8BC1\uFF1A",
  notFound: {
    code: "404",
    title: "\u9875\u9762\u672A\u627E\u5230",
    quote: "\u4F46\u662F\uFF0C\u5982\u679C\u4F60\u4E0D\u6539\u53D8\u65B9\u5411\uFF0C\u5E76\u4E14\u4E00\u76F4\u5BFB\u627E\uFF0C\u6700\u7EC8\u53EF\u80FD\u4F1A\u5230\u8FBE\u4F60\u8981\u53BB\u7684\u5730\u65B9\u3002",
    linkText: "\u8FD4\u56DE\u9996\u9875"
  },
  homeText: "\u9996\u9875",
  blogText: "\u535A\u5BA2",
  tagText: "\u6807\u7B7E",
  archiveText: "\u5F52\u6863",
  categoryText: "\u5206\u7C7B",
  archiveTotalText: "{count} \u7BC7",
  encryptButtonText: "\u786E\u8BA4",
  encryptPlaceholder: "\u8BF7\u8F93\u5165\u5BC6\u7801",
  encryptGlobalText: "\u672C\u7AD9\u53EA\u5141\u8BB8\u5BC6\u7801\u8BBF\u95EE",
  encryptPageText: "\u672C\u9875\u9762\u53EA\u5141\u8BB8\u5BC6\u7801\u8BBF\u95EE",
  footer: {
    message: 'Powered by <a target="_blank" href="https://v2.vuepress.vuejs.org/">VuePress</a> & <a target="_blank" href="https://theme-plume.vuejs.press">vuepress-theme-plume</a>'
  }
};
var zhPresetLocale = {
  // ------ copyright license ------
  "CC0": "CC0 1.0 \u901A\u7528",
  "CC-BY-4.0": "\u7F72\u540D 4.0 \u56FD\u9645",
  "CC-BY-NC-4.0": "\u7F72\u540D-\u975E\u5546\u4E1A\u6027 4.0 \u56FD\u9645",
  "CC-BY-NC-SA-4.0": "\u7F72\u540D-\u975E\u5546\u4E1A\u6027-\u76F8\u540C\u65B9\u5F0F\u5171\u4EAB 4.0 \u56FD\u9645",
  "CC-BY-NC-ND-4.0": "\u7F72\u540D-\u975E\u5546\u4E1A\u6027-\u7981\u6B62\u6F14\u7ECE 4.0 \u56FD\u9645",
  "CC-BY-ND-4.0": "\u7F72\u540D-\u7981\u6B62\u6F14\u7ECE 4.0 \u56FD\u9645",
  "CC-BY-SA-4.0": "\u7F72\u540D-\u76F8\u540C\u65B9\u5F0F\u5171\u4EAB 4.0 \u56FD\u9645"
};

// src/node/locales/index.ts
var LOCALE_OPTIONS = [
  [["en", "en-US"], enLocale],
  [["zh", "zh-CN", "zh-Hans", "zh-Hant"], zhLocale],
  [["zh-TW"], zhTwLocale],
  [["de", "de-DE"], deLocale],
  [["fr", "fr-FR"], frLocale],
  [["ru", "ru-RU"], ruLocale],
  [["ja", "ja-JP"], jaLocale]
];
var PRESET_LOCALES = [
  [["en", "en-US"], enPresetLocale],
  [["zh", "zh-CN", "zh-Hans", "zh-Hant"], zhPresetLocale],
  [["zh-TW"], zhTwPresetLocale],
  [["de", "de-DE"], dePresetLocale],
  [["fr", "fr-FR"], frPresetLocale],
  [["ru", "ru-RU"], ruPresetLocale],
  [["ja", "ja-JP"], jaPresetLocale]
];

// src/node/config/initThemeOptions.ts
var FALLBACK_OPTIONS = {
  appearance: true,
  blog: {
    pagination: 15,
    postList: true,
    tags: true,
    archives: true,
    categories: true,
    link: "/blog/",
    tagsLink: "/blog/tags/",
    archivesLink: "/blog/archives/",
    categoriesLink: "/blog/categories/"
  },
  article: "/article/",
  notes: { link: "/", dir: "/notes/", notes: [] },
  navbarSocialInclude: ["github", "twitter", "discord", "facebook"],
  aside: true,
  outline: [2, 3],
  externalLinkIcon: true,
  // page meta
  editLink: true,
  contributors: true,
  changelog: false,
  prevPage: true,
  nextPage: true,
  footer: {
    message: 'Power by <a target="_blank" href="https://v2.vuepress.vuejs.org/">VuePress</a> & <a target="_blank" href="https://theme-plume.vuejs.press">vuepress-theme-plume</a>'
  }
};
function initThemeOptions(app, { locales, ...options }) {
  const resolvedOptions = {
    ...mergeOptions(FALLBACK_OPTIONS, options),
    locales: getFullLocaleConfig({
      app,
      name: THEME_NAME,
      default: LOCALE_OPTIONS,
      config: fromEntries(
        entries({
          "/": {},
          ...locales
        }).map(([locale, opt]) => [
          locale,
          mergeOptions(options, opt)
        ])
      )
    })
  };
  return resolvedOptions;
}
function mergeOptions(target, source) {
  const res = {};
  const keys = uniq([...Object.keys(target), ...Object.keys(source)]);
  for (const key of keys) {
    if (hasOwn(source, key)) {
      const value = source[key];
      const targetValue = target[key];
      if (isPlainObject(targetValue) && isPlainObject(value)) {
        res[key] = Object.assign({}, targetValue, value);
      } else {
        res[key] = value;
      }
    } else {
      res[key] = target[key];
    }
  }
  return res;
}

// src/node/loadConfig/loader.ts
var loader = null;
async function initConfigLoader(app, { configFile, onChange, defaultConfig }) {
  perf.mark("load-config");
  loader = {
    configFile,
    dependencies: [],
    load: () => compiler(loader.configFile),
    loaded: false,
    changeEvents: [],
    whenLoaded: [],
    defaultConfig,
    config: initThemeOptions(app, defaultConfig)
  };
  perf.mark("load-config:find");
  loader.configFile = await findConfigPath(app, configFile);
  perf.log("load-config:find");
  if (onChange) {
    loader.changeEvents.push(onChange);
  }
  perf.mark("load-config:loaded");
  const { config, dependencies = [] } = await loader.load();
  perf.log("load-config:loaded");
  loader.loaded = true;
  loader.dependencies = [...dependencies];
  updateResolvedConfig(app, config);
  loader.whenLoaded.forEach((fn) => fn(loader.config));
  loader.whenLoaded = [];
  perf.log("load-config");
}
function watchConfigFile(app, watchers, onChange) {
  if (!loader || !loader.configFile)
    return;
  const watcher = watch(loader.configFile, {
    ignoreInitial: true,
    cwd: process4.cwd()
  });
  addDependencies(watcher);
  onConfigChange(onChange);
  watcher.on("change", async () => {
    if (loader) {
      loader.loaded = false;
      const { config, dependencies = [] } = await loader.load();
      loader.loaded = true;
      addDependencies(watcher, dependencies);
      updateResolvedConfig(app, config);
      runChangeEvents();
    }
  });
  watcher.on("unlink", async () => {
    updateResolvedConfig(app);
    runChangeEvents();
  });
  watchers.push(watcher);
}
async function onConfigChange(onChange) {
  if (loader && !loader.changeEvents.includes(onChange)) {
    loader.changeEvents.push(onChange);
    if (loader.loaded) {
      await onChange(loader.config);
    }
  }
}
function waitForConfigLoaded() {
  return new Promise((resolve3) => {
    if (loader?.loaded) {
      resolve3(loader.config);
    } else {
      loader?.whenLoaded.push(resolve3);
    }
  });
}
function getThemeConfig() {
  return loader.config;
}
function updateResolvedConfig(app, userConfig = {}) {
  if (loader) {
    const config = deepMerge({}, loader.defaultConfig, userConfig);
    loader.config = initThemeOptions(app, config);
  }
}
async function runChangeEvents() {
  if (loader) {
    await Promise.all(loader.changeEvents.map((fn) => fn(loader.config)));
  }
}
function addDependencies(watcher, dependencies) {
  if (!loader)
    return;
  if (dependencies?.length) {
    const deps = dependencies.filter((dep) => !loader.dependencies.includes(dep) && dep[0] === ".");
    loader.dependencies.push(...deps);
    watcher.add(deps);
  } else {
    watcher.add(loader.dependencies);
  }
}

// src/node/autoFrontmatter/readFile.ts
import fg from "fast-glob";
import { fs as fs4, path as path5 } from "vuepress/utils";
async function readMarkdownList(app, { globFilter, checkCache }) {
  const source = app.dir.source();
  const files = await fg(["**/*.md"], {
    cwd: source,
    ignore: ["node_modules", ".vuepress"]
  });
  return await Promise.all(
    files.filter((id) => {
      if (!globFilter(id))
        return false;
      return checkCache(path5.join(source, id));
    }).map((file) => readMarkdown(source, file))
  );
}
async function readMarkdown(sourceDir, relativePath) {
  const filepath = path5.join(sourceDir, relativePath);
  const stats = await fs4.promises.stat(filepath);
  return {
    filepath,
    relativePath: normalizePath(relativePath),
    content: await fs4.promises.readFile(filepath, "utf-8"),
    createTime: getFileCreateTime(stats),
    stats
  };
}
function getFileCreateTime(stats) {
  return stats.birthtime.getFullYear() !== 1970 ? stats.birthtime : stats.atime;
}

// src/node/autoFrontmatter/resolveOptions.ts
import { uniq as uniq3 } from "@pengzhanbo/utils";
import { ensureLeadingSlash as ensureLeadingSlash2 } from "@vuepress/helper";
import { resolveLocalePath } from "vuepress/shared";
import { path as path7 } from "vuepress/utils";

// src/node/config/extendsBundlerOptions.ts
import {
  addViteConfig,
  addViteOptimizeDepsExclude,
  addViteOptimizeDepsInclude,
  addViteSsrNoExternal,
  chainWebpack
} from "@vuepress/helper";
import { isPackageExists } from "local-pkg";
function extendsBundlerOptions(bundlerOptions, app) {
  addViteConfig(bundlerOptions, app, {
    build: {
      chunkSizeWarningLimit: 2048
    }
  });
  addViteOptimizeDepsInclude(
    bundlerOptions,
    app,
    ["@vueuse/core", "bcrypt-ts/browser", "@vuepress/helper/client", "@iconify/vue", "@iconify/vue/offline", "@vuepress/plugin-git/client"]
  );
  addViteOptimizeDepsExclude(bundlerOptions, app, "@theme");
  addViteSsrNoExternal(bundlerOptions, app, [
    "@vuepress/helper",
    "@vuepress/plugin-reading-time",
    "@vuepress/plugin-watermark"
  ]);
  if (isPackageExists("swiper")) {
    addViteOptimizeDepsInclude(bundlerOptions, app, ["swiper/modules", "swiper/vue"]);
    addViteSsrNoExternal(bundlerOptions, app, ["swiper"]);
  }
  const silenceDeprecations = ["mixed-decls", "legacy-js-api", "import", "global-builtin"];
  chainWebpack(bundlerOptions, app, (config) => {
    config.module.rule("scss").use("sass-loader").tap((options) => ({
      ...options,
      sassOptions: {
        silenceDeprecations,
        ...options.sassOptions
      }
    }));
  });
  addViteConfig(bundlerOptions, app, {
    css: {
      preprocessorOptions: {
        sass: {
          silenceDeprecations
        },
        scss: {
          silenceDeprecations
        }
      }
    }
  });
}

// src/node/config/resolveNotesOptions.ts
import { uniq as uniq2 } from "@pengzhanbo/utils";
import { entries as entries2, removeLeadingSlash } from "@vuepress/helper";
function resolveNotesLinkList(options) {
  const locales = options.locales || {};
  const notesLinks = [];
  for (const [locale, opt] of entries2(locales)) {
    const config = locale === "/" ? opt.notes || options.notes : opt.notes;
    if (config && config.notes?.length) {
      const prefix = config.link || "";
      notesLinks.push(
        ...config.notes.map(
          (note) => withBase(`${prefix}/${note.link || ""}`, locale)
        )
      );
    }
  }
  return uniq2(notesLinks);
}
function resolveNotesOptions(options) {
  const locales = options.locales || {};
  const notesOptionsList = [];
  for (const [locale, opt] of entries2(locales)) {
    const current = locale === "/" ? opt.notes || options.notes : opt.notes;
    if (current) {
      current.dir = withBase(current.dir, locale);
      notesOptionsList.push(current);
    }
  }
  return notesOptionsList;
}
function resolveNotesDirs(options) {
  const notesList = resolveNotesOptions(options);
  return uniq2(notesList.flatMap(
    ({ notes, dir }) => notes.map((note) => removeLeadingSlash(normalizePath(`${dir}/${note.dir || ""}/`)))
  ));
}

// src/node/config/resolveThemeData.ts
import { entries as entries3, isBoolean, isPlainObject as isPlainObject2 } from "@vuepress/helper";
var EXCLUDE_LIST = [
  "hostname",
  "locales",
  "sidebar",
  "navbar",
  "notes",
  "sidebar",
  "article",
  "changelog",
  "contributors",
  "bulletin",
  "cache",
  "autoFrontmatter",
  "comment",
  "codeHighlighter",
  "markdown",
  "configFile",
  "encrypt",
  "plugins",
  "search",
  "watermark",
  "readingTime",
  "copyCode"
];
var EXCLUDE_LOCALE_LIST = [...EXCLUDE_LIST, "blog", "appearance"];
function resolveThemeData(app, options) {
  const themeData = { locales: {} };
  entries3(options).forEach(([key, value]) => {
    if (!EXCLUDE_LIST.includes(key))
      themeData[key] = value;
  });
  themeData.contributors = isPlainObject2(options.contributors) ? { mode: options.contributors.mode || "inline" } : isBoolean(options.contributors) ? options.contributors : true;
  themeData.changelog = !!options.changelog;
  if (isPlainObject2(options.bulletin)) {
    const { enablePage: _, ...opt } = options.bulletin;
    themeData.bulletin = opt;
  } else if (options.bulletin) {
    themeData.bulletin = options.bulletin;
  }
  if (isPlainObject2(options.blog)) {
    const { categoriesTransform, include, exclude, ...blog } = options.blog;
    themeData.blog = blog;
  } else {
    themeData.blog = options.blog;
  }
  entries3(options.locales || {}).forEach(([locale, opt]) => {
    themeData.locales[locale] = {};
    entries3(opt).forEach(([key, value]) => {
      if (!EXCLUDE_LOCALE_LIST.includes(key))
        themeData.locales[locale][key] = value;
    });
    if (isPlainObject2(opt.bulletin)) {
      const { enablePage: _, ...rest } = opt.bulletin;
      themeData.locales[locale].bulletin = rest;
    } else if (opt.bulletin) {
      themeData.locales[locale].bulletin = opt.bulletin;
    }
  });
  entries3(options.locales || {}).forEach(([locale, opt]) => {
    if (opt.navbar !== false && (!opt.navbar || opt.navbar.length === 0)) {
      const navbar = [{
        text: opt.homeText || options.homeText || "Home",
        link: locale
      }];
      if (options.blog !== false) {
        const blog = options.blog || {};
        const blogLink = blog.link || "/blog/";
        navbar.push({
          text: opt.blogText || options.blogText || "Blog",
          link: withBase(blogLink, locale)
        });
        if (blog.tags !== false) {
          navbar.push({
            text: opt.tagText || options.tagText || "Tags",
            link: withBase(blog.tagsLink || `${blogLink}/tags/`, locale)
          });
        }
        if (blog.archives !== false) {
          navbar.push({
            text: opt.archiveText || options.archiveText || "Archives",
            link: withBase(blog.archivesLink || `${blogLink}/archives/`, locale)
          });
        }
      }
      themeData.locales[locale].navbar = navbar;
    } else {
      themeData.locales[locale].navbar = opt.navbar;
    }
  });
  return themeData;
}

// src/node/config/setupAlias.ts
import { fs as fs5, path as path6 } from "vuepress/utils";
function setupAlias() {
  return {
    ...Object.fromEntries(
      fs5.readdirSync(
        resolve("client/components"),
        { encoding: "utf-8", recursive: true }
      ).filter((file) => file.endsWith(".vue")).map((file) => [
        path6.join("@theme", file),
        resolve("client/components", file)
      ])
    )
  };
}

// src/node/config/setupProvideData.ts
import { getFullLocaleConfig as getFullLocaleConfig2, isPlainObject as isPlainObject3 } from "@vuepress/helper";
function setupProvideData(app, plugins) {
  const options = getThemeConfig();
  const watermark = options.watermark ?? plugins.watermark;
  return {
    // 注入水印配置
    __PLUME_WM_FP__: isPlainObject3(watermark) ? watermark.fullPage !== false : true,
    // 注入多语言配置
    __PLUME_PRESET_LOCALE__: getFullLocaleConfig2({
      app,
      name: "vuepress-theme-plume/preset-locales",
      default: PRESET_LOCALES
    })
  };
}

// src/node/config/templateBuildRenderer.ts
import { templateRenderer } from "vuepress/utils";
function templateBuildRenderer(template, context) {
  const options = getThemeConfig();
  const pkg = getThemePackage();
  template = template.replace("{{ themeVersion }}", pkg.version || "").replace(/^\s+|\s+$/gm, "").replace(/\n/g, "");
  if (options.appearance ?? true) {
    const appearance = typeof options.appearance === "string" ? options.appearance : "auto";
    const script = appearance === "force-dark" ? `document.documentElement.dataset.theme = 'dark'` : `;(function () {
    const um= localStorage.getItem('vuepress-theme-appearance') || '${appearance}';
    const sm = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
    const isDark = um === 'dark' || (um !== 'light' && sm);
    document.documentElement.dataset.theme = isDark ? 'dark' : 'light';
  })();`.replace(/^\s+|\s+$/gm, "").replace(/\n/g, "");
    template = template.replace("<!--vuepress-theme-plume-appearance-->", `<script id="check-dark-mode">${script}</script>`);
  } else {
    template = template.replace("<!--vuepress-theme-plume-appearance-->", "");
  }
  return templateRenderer(template, context);
}

// src/node/autoFrontmatter/baseFrontmatter.ts
import dayjs from "dayjs";
function createBaseFrontmatter(autoFrontmatter) {
  const res = {};
  if (autoFrontmatter.createTime !== false) {
    res.createTime = (formatTime, { createTime }, data) => {
      if (formatTime)
        return formatTime;
      if (data.friends || data.pageLayout === "friends")
        return;
      return dayjs(new Date(createTime)).format("YYYY/MM/DD HH:mm:ss");
    };
  }
  return res;
}

// src/node/autoFrontmatter/resolveLinkBySidebar.ts
function resolveLinkBySidebar(sidebar, _prefix) {
  const res = {};
  if (sidebar === "auto") {
    return res;
  }
  for (const item of sidebar) {
    if (typeof item !== "string") {
      const { prefix, dir = "", link = "/", items, text = "" } = item;
      getSidebarLink(items, link, text, pathJoin(_prefix, prefix || dir), res);
    }
  }
  return res;
}
function getSidebarLink(items, link, text, dir = "", res = {}) {
  if (items === "auto")
    return;
  if (!items) {
    res[pathJoin(dir, `${text}.md`)] = link;
    return;
  }
  for (const item of items) {
    if (typeof item === "string") {
      if (!link)
        continue;
      if (item) {
        res[pathJoin(dir, `${item}.md`)] = link;
      } else {
        res[pathJoin(dir, "README.md")] = link;
        res[pathJoin(dir, "index.md")] = link;
        res[pathJoin(dir, "readme.md")] = link;
      }
      res[dir] = link;
    } else {
      const { prefix, dir: subDir = "", link: subLink = "/", items: subItems, text: subText = "" } = item;
      getSidebarLink(subItems, pathJoin(link, subLink), subText, pathJoin(prefix || dir, subDir), res);
    }
  }
}

// src/node/autoFrontmatter/resolveOptions.ts
function resolveOptions(options, autoFrontmatter) {
  const resolveLocale = (relativeFilepath) => resolveLocalePath(options.locales, ensureLeadingSlash2(relativeFilepath));
  const findNotesByLocale = (locale) => {
    const notes = options.locales?.[locale]?.notes;
    return notes === false ? void 0 : notes;
  };
  const findNote = (relativeFilepath) => {
    const locale = resolveLocale(relativeFilepath);
    const filepath = ensureLeadingSlash2(relativeFilepath);
    const notes = findNotesByLocale(locale);
    if (!notes)
      return void 0;
    const notesList = notes?.notes || [];
    const notesDir = notes?.dir || "";
    return notesList.find(
      (note) => filepath.startsWith(normalizePath(`${notesDir}/${note.dir}`))
    );
  };
  const baseFrontmatter = createBaseFrontmatter(autoFrontmatter);
  const localesNotesDirs = resolveNotesDirs(options);
  const configs = [];
  if (localesNotesDirs.length) {
    configs.push({
      include: localesNotesDirs.map((dir) => pathJoin(dir, "/{readme,README,index}.md")),
      frontmatter: {
        title(title, { relativePath }) {
          if (title)
            return title;
          if (autoFrontmatter.title === false)
            return;
          return findNote(relativePath)?.text || getCurrentDirname("", relativePath);
        },
        ...baseFrontmatter,
        permalink(permalink, { relativePath }, data) {
          if (permalink)
            return permalink;
          if (autoFrontmatter.permalink === false || data.friends || data.pageLayout === "friends")
            return;
          const locale = resolveLocale(relativePath);
          const prefix = findNotesByLocale(locale)?.link || "";
          const note = findNote(relativePath);
          return pathJoin(
            prefix.startsWith(locale) ? "/" : locale,
            prefix,
            note?.link || getCurrentDirname(note?.dir, relativePath),
            "/"
          );
        }
      }
    });
    configs.push({
      include: localesNotesDirs.map((dir) => `${dir}**/**.md`),
      frontmatter: {
        title(title, { relativePath }) {
          if (title)
            return title;
          if (autoFrontmatter.title === false)
            return;
          return path7.basename(relativePath, ".md").replace(/^\d+\./, "");
        },
        ...baseFrontmatter,
        permalink(permalink, { relativePath }, data) {
          if (permalink)
            return permalink;
          if (autoFrontmatter.permalink === false)
            return;
          if (data.friends || data.pageLayout === "friends")
            return;
          const locale = resolveLocale(relativePath);
          const notes = findNotesByLocale(locale);
          const note = findNote(relativePath);
          const prefix = notes?.link || "";
          const args = [
            prefix.startsWith(locale) ? "/" : locale,
            prefix,
            note?.link || ""
          ];
          const sidebar = note?.sidebar;
          if (note && sidebar && sidebar !== "auto") {
            const res = resolveLinkBySidebar(sidebar, pathJoin(notes?.dir || "", note.dir || ""));
            const file = ensureLeadingSlash2(relativePath);
            if (res[file]) {
              args.push(res[file]);
            } else if (res[path7.dirname(file)]) {
              args.push(res[path7.dirname(file)]);
            }
          }
          return pathJoin(...args, nanoid(), "/");
        }
      }
    });
  }
  configs.push({
    include: "**/{readme,README,index}.md",
    frontmatter: {}
  });
  if (options.blog !== false) {
    configs.push({
      include: options.blog?.include ?? ["**/*.md"],
      frontmatter: {
        title(title, { relativePath }) {
          if (title)
            return title;
          if (autoFrontmatter.title === false)
            return;
          return path7.basename(relativePath || "", ".md");
        },
        ...baseFrontmatter,
        permalink(permalink, { relativePath }) {
          if (permalink)
            return permalink;
          if (autoFrontmatter.permalink === false)
            return;
          const locale = resolveLocale(relativePath);
          const prefix = withBase(options.article || "/article/", locale);
          return normalizePath(`${prefix}/${nanoid()}/`);
        }
      }
    });
  }
  configs.push({
    include: "*",
    frontmatter: {
      title(title, { relativePath }) {
        if (title)
          return title;
        if (autoFrontmatter.title === false)
          return;
        return path7.basename(relativePath || "", ".md");
      },
      ...baseFrontmatter,
      permalink(permalink, { relativePath }) {
        if (permalink)
          return permalink;
        if (autoFrontmatter.permalink === false)
          return;
        return ensureLeadingSlash2(normalizePath(relativePath.replace(/\.md$/, "/")));
      }
    }
  });
  return {
    include: autoFrontmatter?.include ?? ["**/*.md"],
    exclude: uniq3([".vuepress/**/*", "node_modules", ...autoFrontmatter?.exclude ?? []]),
    frontmatter: configs
  };
}

// src/node/autoFrontmatter/generator.ts
var CACHE_FILE = "markdown/auto-frontmatter.json";
var generate = null;
function initAutoFrontmatter() {
  const { autoFrontmatter = {}, ...options } = getThemeConfig();
  if (autoFrontmatter === false)
    return;
  const { include, exclude, frontmatter = {} } = resolveOptions(options, autoFrontmatter);
  const globFilter = createFilter(include, exclude, { resolve: false });
  const userConfig = isArray(frontmatter) ? frontmatter : [{ include: "*", frontmatter }];
  const globalConfig = userConfig.find(({ include: include2 }) => include2 === "*")?.frontmatter || {};
  const rules = userConfig.filter(({ include: include2 }) => include2 !== "*").map(({ include: include2, frontmatter: frontmatter2 }) => {
    return {
      include: include2,
      filter: createFilter(toArray(include2), void 0, { resolve: false }),
      frontmatter: frontmatter2
    };
  });
  const cache4 = {};
  function checkCache(filepath) {
    const stats = fs6.statSync(filepath);
    if (cache4[filepath] && cache4[filepath] === stats.mtimeMs.toString())
      return false;
    cache4[filepath] = stats.mtimeMs.toString();
    return true;
  }
  async function updateCache(app) {
    if (!isEmptyObject2(cache4)) {
      await fs6.mkdir(path8.dirname(app.dir.cache(CACHE_FILE)), { recursive: true });
      await fs6.writeFile(app.dir.cache(CACHE_FILE), JSON.stringify(cache4), "utf-8");
    }
  }
  generate = {
    globFilter,
    global: globalConfig,
    rules,
    cache: cache4,
    checkCache,
    updateCache
  };
}
async function generateAutoFrontmatter(app) {
  perf.mark("generate:frontmatter");
  if (!generate)
    return;
  const cachePath = app.dir.cache(CACHE_FILE);
  if (fs6.existsSync(cachePath)) {
    try {
      generate.cache = JSON.parse(await fs6.readFile(cachePath, "utf-8"));
    } catch {
      generate.cache = {};
    }
  }
  const markdownList = await readMarkdownList(app, generate);
  await promiseParallel(
    markdownList.map((file) => () => generator(file)),
    64
  );
  await generate.updateCache(app);
  perf.log("generate:frontmatter");
}
async function watchAutoFrontmatter(app, watchers) {
  if (!generate)
    return;
  const watcher = chokidar.watch("**/*.md", {
    cwd: app.dir.source(),
    ignoreInitial: true,
    ignored: /(node_modules|\.vuepress)\//
  });
  watcher.on("add", async (relativePath) => {
    const enabled = getThemeConfig().autoFrontmatter !== false;
    if (!generate.globFilter(relativePath) || !enabled)
      return;
    const file = await readMarkdown(app.dir.source(), relativePath);
    await generator(file);
  });
  watcher.on("change", async (relativePath) => {
    const enabled = getThemeConfig().autoFrontmatter !== false;
    if (!generate.globFilter(relativePath) || !enabled)
      return;
    if (generate.checkCache(path8.join(app.dir.source(), relativePath)))
      await generate.updateCache(app);
  });
  watchers.push(watcher);
}
async function generator(file) {
  if (!generate)
    return;
  const { filepath, relativePath } = file;
  const current = generate.rules.find(({ filter }) => filter(relativePath));
  const formatter = current?.frontmatter || generate.global;
  const { data, content } = grayMatter(file.content);
  const beforeHash = hash3(data);
  for (const key in formatter) {
    const value = await formatter[key](data[key], file, data) ?? data[key];
    if (typeof value !== "undefined")
      data[key] = value;
    else
      delete data[key];
  }
  if (beforeHash === hash3(data))
    return;
  try {
    const yaml = isEmptyObject2(data) ? "" : jsonToYaml.stringify(data).replace(/\n\s{2}/g, "\n").replace(/"/g, "").replace(/\s+\n/g, "\n");
    const newContent = yaml ? `${yaml}---
${content}` : content;
    await fs6.promises.writeFile(filepath, newContent, "utf-8");
    generate.checkCache(filepath);
  } catch (e) {
    console.error(
      colors3.red("[vuepress-theme-plume:auto-frontmatter] "),
      `error in: ${colors3.cyan(relativePath)}
`,
      e
    );
  }
}

// src/node/detector/fields.ts
var PLUGINS_SUPPORTED_FIELDS = [
  "search",
  "docsearch",
  "copyCode",
  "shiki",
  "git",
  "nprogress",
  "photoSwipe",
  "markdownEnhance",
  "markdownPower",
  "markdownImage",
  "markdownMath",
  "markdownInclude",
  "comment",
  "sitemap",
  "seo",
  "cache",
  "readingTime",
  "watermark",
  "replaceAssets"
];
var MARKDOWN_ENHANCE_FIELDS = [
  "chartjs",
  "echarts",
  "mermaid",
  "markmap",
  "plantuml",
  "flowchart",
  "revealJs",
  "playground",
  "vuePlayground",
  "kotlinPlayground",
  "sandpack"
];
var MARKDOWN_POWER_FIELDS = [
  "abbr",
  "annotation",
  "artPlayer",
  "audioReader",
  "bilibili",
  "caniuse",
  "codeSandbox",
  "codeTabs",
  "codepen",
  "demo",
  "fileTree",
  "icons",
  "imageSize",
  "jsfiddle",
  "npmTo",
  "pdf",
  "plot",
  "repl",
  "replit",
  "timeline",
  "collapse",
  "chat",
  "youtube"
];
var MARKDOWN_SUPPORT_FIELDS = [
  ...MARKDOWN_ENHANCE_FIELDS,
  ...MARKDOWN_POWER_FIELDS,
  "oldDemo",
  "image",
  "math",
  "include",
  "hint",
  "alert"
];

// src/node/detector/dependency.ts
import { isEmptyObject as isEmptyObject3, isPlainObject as isPlainObject4 } from "@pengzhanbo/utils";
import { isPackageExists as isPackageExists2 } from "local-pkg";
import { getUserAgent, resolveCommand } from "package-manager-detector";
import { colors as colors4 } from "vuepress/utils";
var DEPENDENCIES = {
  twoslash: ["@vuepress/shiki-twoslash"],
  chartjs: ["chart.js"],
  echarts: ["echarts"],
  markmap: ["markmap-lib", "markmap-toolbar", "markmap-view"],
  mermaid: ["mermaid"],
  flowchart: ["flowchart.ts"],
  artPlayer: ["artplayer"],
  mathjax: ["mathjax-full"]
};
var t = createTranslate({
  en: {
    notFoundDeps: "Enabling features such as {{ features }} requires the installation of the following dependencies: {{ dependencies }}",
    install: "Run the command to install:  {{ command }}"
  },
  zh: {
    notFoundDeps: "\u542F\u7528 {{ features }} \u7B49\u529F\u80FD\u9700\u8981\u5B89\u88C5\u4EE5\u4E0B\u4F9D\u8D56: {{ dependencies }}",
    install: "\u8FD0\u884C\u5B89\u88C5\u547D\u4EE4:  {{ command }}"
  }
});
function detectDependencies(options, plugins) {
  const shouldInstall = {};
  const markdown = options.markdown || {};
  const mdPower = isPlainObject4(plugins.markdownPower) ? plugins.markdownPower : {};
  const mdEnhance = isPlainObject4(plugins.markdownEnhance) ? plugins.markdownEnhance : {};
  const add = (name) => {
    const list = DEPENDENCIES[name].filter((dep) => !isPackageExists2(dep));
    if (list.length)
      shouldInstall[name] = list;
  };
  if (options.codeHighlighter && options.codeHighlighter.twoslash)
    add("twoslash");
  ["chartjs", "echarts", "markmap", "mermaid", "flowchart"].forEach((dep) => {
    if (markdown[dep] || mdEnhance[dep])
      add(dep);
  });
  const math = markdown.math || plugins.markdownMath;
  if (math && math.type === "mathjax")
    add("mathjax");
  if (markdown.artPlayer || mdPower.artPlayer)
    add("artPlayer");
  if (isEmptyObject3(shouldInstall))
    return;
  const features = Object.keys(shouldInstall);
  const dependencies = Object.values(shouldInstall).flat();
  logger.error(t("notFoundDeps", {
    features: features.map((feat) => colors4.green(feat)).join(", "),
    dependencies: dependencies.map((dep) => colors4.magenta(dep)).join(", ")
  }));
  const agent = getUserAgent();
  if (agent) {
    const { command = "", args = [] } = resolveCommand(agent, "add", dependencies) || {};
    logger.info(t("install", {
      command: colors4.cyan(`${command} ${args.join(" ").replace(DEPENDENCIES.twoslash[0], `${DEPENDENCIES.twoslash[0]}@next`)}`)
    }));
  }
}

// src/node/detector/markdown.ts
import { colors as colors5 } from "vuepress/utils";
var t2 = createTranslate({
  en: { message: "{{ markdown }} unsupported fields: {{ unsupported }}, please check your config." },
  zh: { message: "{{ markdown }} \u4E0D\u652F\u6301\u4EE5\u4E0B\u5B57\u6BB5: {{ unsupported }}, \u8BF7\u68C0\u67E5\u4F60\u7684\u914D\u7F6E\u3002" }
});
function detectMarkdown(options) {
  const { markdown } = options;
  if (!markdown)
    return;
  const unsupported = Object.keys(markdown).filter((key) => !MARKDOWN_SUPPORT_FIELDS.includes(key));
  if (unsupported.length) {
    logger.warn(t2("message", {
      markdown: colors5.green("markdown"),
      unsupported: unsupported.map((field) => colors5.magenta(`"${field}"`)).join(", ")
    }));
  }
}

// src/node/detector/plugins.ts
import { colors as colors6 } from "vuepress/utils";
var t3 = createTranslate({
  en: { message: "{{ plugins }} unsupported fields: {{ unsupported }}, please check your config." },
  zh: { message: "{{ plugins }} \u4E0D\u652F\u6301\u4EE5\u4E0B\u5B57\u6BB5: {{ unsupported }}, \u8BF7\u68C0\u67E5\u4F60\u7684\u914D\u7F6E\u3002" }
});
function detectPlugins(plugins) {
  if (Array.isArray(plugins)) {
    logger.warn(`${colors6.green("plugins")} only accept object config, please check your config.`);
  }
  const unsupportedPluginsFields = Object.keys(plugins).filter((field) => !PLUGINS_SUPPORTED_FIELDS.includes(field));
  if (unsupportedPluginsFields.length) {
    logger.warn(t3("message", {
      plugins: colors6.green("plugins"),
      unsupported: unsupportedPluginsFields.map((field) => colors6.magenta(`"${field}"`)).join(", ")
    }));
  }
}

// src/node/detector/options.ts
function detectThemeOptions({
  plugins = {},
  configFile,
  ...themeOptions
}) {
  detectDependencies(themeOptions, plugins);
  detectMarkdown(themeOptions);
  detectPlugins(plugins);
  return { configFile, plugins, themeOptions };
}

// src/node/detector/versions.ts
import fs7 from "node:fs";
import path9 from "node:path";
import { isEmptyObject as isEmptyObject4 } from "@pengzhanbo/utils";
import { colors as colors7 } from "vuepress/utils";
var t4 = createTranslate({
  en: {
    title: "The following dependencies have version mismatches:",
    footer: "Please update the dependencies to the correct versions."
  },
  zh: {
    title: "\u4EE5\u4E0B\u4F9D\u8D56\u7248\u672C\u4E0D\u5339\u914D\uFF1A",
    footer: "\u8BF7\u66F4\u65B0\u4F9D\u8D56\u81F3\u6B63\u786E\u7684\u7248\u672C\u3002"
  }
});
function detectVersions(app) {
  detectVuepressVersion();
  detectThemeVersion(app);
}
function detectVuepressVersion() {
  const themePackage = getThemePackage();
  const userPackage = getPackage();
  const vuepressDeps = Object.entries({
    "vuepress-theme-plume": themePackage.version,
    "@vuepress/bundler-vite": themePackage.peerDependencies?.vuepress,
    "@vuepress/bundler-webpack": themePackage.peerDependencies?.vuepress,
    ...themePackage.dependencies,
    ...themePackage.peerDependencies
  }).reduce((deps, [name, version]) => {
    if (name.includes("vuepress") && version && version !== "workspace:*")
      deps[name] = version;
    return deps;
  }, {});
  const detect = (deps) => {
    const results = [];
    if (!deps || isEmptyObject4(deps))
      return results;
    for (const [name, version] of Object.entries(deps)) {
      const resolved = resolveVersion(version);
      if (resolved && vuepressDeps[name] && vuepressDeps[name] !== resolved)
        results.push({ name, expected: vuepressDeps[name], current: version });
    }
    return results;
  };
  const devResults = detect(userPackage.devDependencies);
  const prodResults = detect(userPackage.dependencies);
  if (devResults.length || prodResults.length) {
    const output = (deps) => deps.map((dep) => `  ${colors7.green(dep.name)}: ${colors7.gray(dep.current)} -> ${colors7.cyan(dep.expected)}`).join("  \n");
    logger.warn(`${t4("title")}
${devResults.length ? `
devDependencies:
${output(devResults)}
` : ""}${prodResults.length ? `
dependencies:
${output(prodResults)}
` : ""}
${t4("footer")}
`);
  }
}
function detectThemeVersion(app) {
  if (app.env.isBuild)
    return;
  try {
    const versionCache = app.dir.cache(".theme-plume-version");
    const themePackage = getThemePackage();
    const current = themePackage.version;
    const updateCache = () => {
      fs7.mkdirSync(path9.dirname(versionCache), { recursive: true });
      fs7.writeFileSync(versionCache, current, "utf-8");
    };
    if (!fs7.existsSync(versionCache)) {
      updateCache();
      return;
    }
    const cached = fs7.readFileSync(versionCache, "utf-8") || "";
    if (cached === current)
      return;
    fs7.rmSync(app.dir.cache(), { recursive: true });
    fs7.rmSync(app.dir.temp(), { recursive: true });
    updateCache();
  } catch {
  }
}
var RE_FLAG = /^[\^~<>=]+/;
function resolveVersion(version) {
  if (RE_FLAG.test(version))
    return version.replace(RE_FLAG, "");
  if (/^\d/.test(version))
    return version;
  return "";
}

// src/node/pages/createPages.ts
import { createPage } from "vuepress/core";
function getRootLang(app) {
  const siteLocales = app.siteData.locales;
  if (siteLocales["/"]?.lang)
    return siteLocales["/"].lang;
  return app.siteData.lang;
}
async function createPages(app) {
  const options = getThemeConfig();
  if (options.blog === false)
    return;
  perf.mark("create:blog-pages");
  const pageList = [];
  const locales = options.locales || {};
  const rootLang = getRootLang(app);
  const blog = options.blog || {};
  const link = blog.link || "/blog/";
  for (const localePath of Object.keys(locales)) {
    const lang2 = app.siteData.locales?.[localePath]?.lang || rootLang;
    const opt = locales[localePath];
    if (blog.postList !== false) {
      pageList.push(createPage(app, {
        path: withBase(link, localePath),
        frontmatter: { lang: lang2, _pageLayout: "blog", title: opt.blogText || options.blogText || "Blog" }
      }));
    }
    if (blog.tags !== false) {
      pageList.push(createPage(app, {
        path: withBase(blog.tagsLink || `${link}/tags/`, localePath),
        frontmatter: { lang: lang2, _pageLayout: "blog-tags", title: opt.tagText || options.tagText || "Tags" }
      }));
    }
    if (blog.archives !== false) {
      pageList.push(createPage(app, {
        path: withBase(blog.archivesLink || `${link}/archives/`, localePath),
        frontmatter: { lang: lang2, _pageLayout: "blog-archives", title: opt.archiveText || options.archiveText || "Archives" }
      }));
    }
    if (blog.categories !== false) {
      pageList.push(createPage(app, {
        path: withBase(blog.categoriesLink || `${link}/categories/`, localePath),
        frontmatter: { lang: lang2, _pageLayout: "blog-categories", title: opt.categoryText || options.categoryText || "Categories" }
      }));
    }
  }
  app.pages.push(...await Promise.all(pageList));
  perf.log("create:blog-pages");
}

// src/node/pages/autoCategory.ts
import { ensureLeadingSlash as ensureLeadingSlash3, isPlainObject as isPlainObject5 } from "@vuepress/helper";
var uuid = 1e4;
var cache = {};
var RE_CATEGORY = /^(?:(\d+)\.)?([\s\S]+)$/;
var LOCALE_RE;
function autoCategory(page, options) {
  const pagePath = page.filePathRelative;
  const blog = isPlainObject5(options.blog) ? options.blog : {};
  const enabled = blog.categories !== false;
  if (page.data.type || !pagePath || !enabled)
    return;
  const notesLinks = resolveNotesLinkList(options);
  if (notesLinks.some((link) => page.path.startsWith(link)))
    return;
  LOCALE_RE ??= new RegExp(
    `^(${Object.keys(options.locales || {}).filter((l) => l !== "/").join("|")})`
  );
  const list = ensureLeadingSlash3(pagePath).replace(LOCALE_RE, "").replace(/^\//, "").split("/").slice(0, -1);
  const categoryList = list.map((category, index) => {
    const match = category.match(RE_CATEGORY) || [];
    if (!cache[match[2]] && !match[1]) {
      cache[match[2]] = uuid++;
    }
    return {
      id: hash2(list.slice(0, index + 1).join("-")).slice(0, 6),
      sort: Number(match[1] || cache[match[2]]),
      name: match[2]
    };
  });
  page.data.categoryList = blog.categoriesTransform?.(categoryList) || categoryList;
}

// src/node/pages/pageBulletin.ts
import { isFunction, isPlainObject as isPlainObject6 } from "@vuepress/helper";
function enableBulletin(page, options) {
  if (isPlainObject6(options.bulletin)) {
    const enablePage = options.bulletin.enablePage;
    page.data.bulletin = (isFunction(enablePage) ? enablePage(page) : enablePage) ?? true;
  }
  if (options.locales?.[page.pathLocale]) {
    const bulletin = options.locales?.[page.pathLocale].bulletin;
    if (isPlainObject6(bulletin)) {
      const enablePage = bulletin.enablePage;
      page.data.bulletin = (isFunction(enablePage) ? enablePage(page) : enablePage) ?? true;
    }
  }
}

// src/node/pages/extendsPage.ts
function extendsPageData(page) {
  const options = getThemeConfig();
  cleanPageData(page);
  autoCategory(page, options);
  enableBulletin(page, options);
}
function cleanPageData(page) {
  page.data.filePathRelative = page.filePathRelative;
  page.routeMeta.title = page.frontmatter.title || page.title;
  if (page.frontmatter.icon) {
    page.routeMeta.icon = page.frontmatter.icon;
  }
  if (page.frontmatter.home) {
    page.frontmatter.pageLayout = "home";
    delete page.frontmatter.home;
  }
  if (page.frontmatter.article === false) {
    page.frontmatter.draft = true;
  }
  delete page.frontmatter.article;
  if (page.headers) {
    page.data.headers = [];
  }
  if (page.frontmatter.friends) {
    page.frontmatter.draft = true;
    page.data.type = "friends";
    page.permalink = page.permalink ?? "/friends/";
    page.frontmatter.pageLayout = "friends";
    delete page.frontmatter.friends;
  }
  const pageType = page.frontmatter._pageLayout;
  if (pageType) {
    page.frontmatter.draft = true;
    page.data.type = pageType;
    delete page.frontmatter._pageLayout;
  }
  if (page.frontmatter.pageLayout === "blog") {
    page.frontmatter.draft = true;
    page.data.type = "blog";
  }
  if ("externalLink" in page.frontmatter) {
    page.frontmatter.externalLinkIcon = page.frontmatter.externalLink;
    delete page.frontmatter.externalLink;
  }
}

// src/node/plugins/code.ts
import { uniq as uniq4 } from "@pengzhanbo/utils";
import { isPlainObject as isPlainObject7 } from "@vuepress/helper";
import { copyCodePlugin } from "@vuepress/plugin-copy-code";
import { shikiPlugin } from "@vuepress/plugin-shiki";
import { createCodeTabIconGetter } from "vuepress-plugin-md-power";
function codePlugins(pluginOptions) {
  const options = getThemeConfig();
  const plugins = [];
  const copyCode = options.copyCode ?? pluginOptions.copyCode;
  if (copyCode !== false) {
    const { ignoreSelector = [], ...copyCodeOptions } = copyCode || {};
    plugins.push(copyCodePlugin({
      ignoreSelector: uniq4([".vp-copy-ignore", ".diff.remove", ...ignoreSelector]),
      ...copyCodeOptions
    }));
  }
  const shikiOptions = options.codeHighlighter ?? pluginOptions.shiki;
  if (shikiOptions !== false) {
    const { twoslash, langs = [], codeBlockTitle: _, ...restShikiOptions } = isPlainObject7(shikiOptions) ? shikiOptions : {};
    const twoslashOptions = twoslash === true ? {} : twoslash;
    const mdPower = isPlainObject7(pluginOptions.markdownPower) ? pluginOptions.markdownPower : {};
    const getIcon = createCodeTabIconGetter(options.markdown?.codeTabs ?? mdPower.codeTabs);
    plugins.push(shikiPlugin({
      // enable some default features
      notationDiff: true,
      notationErrorLevel: true,
      notationFocus: true,
      notationHighlight: true,
      notationWordHighlight: true,
      highlightLines: true,
      collapsedLines: false,
      langs: uniq4([...twoslash ? ["ts", "js", "vue", "json", "bash", "sh"] : [], ...langs]),
      codeBlockTitle: (title, code) => {
        const icon = getIcon(title);
        return `<div class="code-block-title"><div class="code-block-title-bar"><span class="title">${icon ? `<VPIcon name="${icon}"/>` : ""}${title}</span></div>${code}</div>`;
      },
      twoslash: isPlainObject7(twoslashOptions) ? {
        ...twoslashOptions,
        // inject markdown class
        floatingVue: { classMarkdown: "vp-doc", ...twoslashOptions.floatingVue }
      } : twoslashOptions,
      ..."theme" in restShikiOptions ? {} : { themes: { light: "vitesse-light", dark: "vitesse-dark" } },
      ...restShikiOptions
    }));
  }
  return plugins;
}

// src/node/plugins/markdown.ts
import { isPlainObject as isPlainObject8 } from "@vuepress/helper";
import { markdownHintPlugin } from "@vuepress/plugin-markdown-hint";
import { markdownImagePlugin } from "@vuepress/plugin-markdown-image";
import { markdownIncludePlugin } from "@vuepress/plugin-markdown-include";
import { markdownMathPlugin } from "@vuepress/plugin-markdown-math";
import { mdEnhancePlugin } from "vuepress-plugin-md-enhance";
import { markdownPowerPlugin } from "vuepress-plugin-md-power";
function markdownPlugins(pluginOptions) {
  const options = getThemeConfig();
  const plugins = [];
  let { hint, image, include, math, mdEnhance, mdPower } = splitMarkdownOptions(options.markdown ?? {});
  plugins.push(markdownHintPlugin({
    hint: hint.hint ?? true,
    alert: hint.alert ?? true,
    injectStyles: false
  }));
  if (pluginOptions.markdownEnhance !== false) {
    plugins.push(mdEnhancePlugin({
      ...pluginOptions.markdownEnhance,
      ...mdEnhance
    }));
  }
  if (pluginOptions.markdownPower !== false) {
    const shikiOptions = options.codeHighlighter ?? pluginOptions.shiki;
    const shikiTheme = shikiOptions && "theme" in shikiOptions ? shikiOptions.theme : shikiOptions && "themes" in shikiOptions ? shikiOptions.themes : { light: "vitesse-light", dark: "vitesse-dark" };
    const repl = mdPower?.repl ?? pluginOptions.markdownPower?.repl;
    plugins.push(markdownPowerPlugin({
      fileTree: true,
      plot: true,
      icons: true,
      ...pluginOptions.markdownPower || {},
      ...mdPower,
      repl: repl ? { theme: shikiTheme, ...repl } : repl
    }));
  }
  math ??= pluginOptions.markdownMath;
  if (math !== false) {
    plugins.push(markdownMathPlugin(math ?? { type: "katex" }));
  }
  image ??= pluginOptions.markdownImage;
  if (image) {
    plugins.push(markdownImagePlugin(image));
  }
  include ??= pluginOptions.markdownInclude;
  if (include !== false) {
    plugins.push(markdownIncludePlugin(isPlainObject8(include) ? include : {}));
  }
  return plugins;
}
function splitMarkdownOptions(options) {
  const { hint, alert, oldDemo, image, include, math, ...restOptions } = options;
  const mdEnhance = { demo: oldDemo };
  const mdPower = {};
  for (const key in restOptions) {
    if (MARKDOWN_ENHANCE_FIELDS.includes(key)) {
      mdEnhance[key] = restOptions[key];
    } else if (MARKDOWN_POWER_FIELDS.includes(key)) {
      mdPower[key] = restOptions[key];
    }
  }
  return {
    hint: { hint, alert },
    image,
    include,
    math,
    mdEnhance,
    mdPower
  };
}

// src/node/plugins/setupPlugins.ts
import { fontsPlugin } from "@vuepress-plume/plugin-fonts";
import { searchPlugin } from "@vuepress-plume/plugin-search";
import { isPlainObject as isPlainObject9 } from "@vuepress/helper";
import { cachePlugin } from "@vuepress/plugin-cache";
import { commentPlugin } from "@vuepress/plugin-comment";
import { docsearchPlugin } from "@vuepress/plugin-docsearch";
import { gitPlugin } from "@vuepress/plugin-git";
import { nprogressPlugin } from "@vuepress/plugin-nprogress";
import { photoSwipePlugin } from "@vuepress/plugin-photo-swipe";
import { readingTimePlugin } from "@vuepress/plugin-reading-time";
import { seoPlugin } from "@vuepress/plugin-seo";
import { sitemapPlugin } from "@vuepress/plugin-sitemap";
import { watermarkPlugin } from "@vuepress/plugin-watermark";
import { replaceAssetsPlugin } from "vuepress-plugin-replace-assets";
function setupPlugins(app, pluginOptions) {
  const isProd = app.env.isBuild;
  const options = getThemeConfig();
  const hostname = options.hostname;
  const plugins = [
    fontsPlugin(),
    ...codePlugins(pluginOptions),
    ...markdownPlugins(pluginOptions)
  ];
  if (pluginOptions.nprogress !== false) {
    plugins.push(nprogressPlugin());
  }
  const readingTime = options.readingTime ?? pluginOptions.readingTime;
  if (readingTime !== false) {
    plugins.push(readingTimePlugin({
      locales: {
        "/zh/": { word: "$word \u5B57", less1Minute: "\u5C0F\u4E8E 1 \u5206\u949F", time: "\u7EA6 $time \u5206\u949F" }
      },
      ...readingTime
    }));
  }
  if (pluginOptions.photoSwipe !== false) {
    plugins.push(photoSwipePlugin({
      selector: ".plume-content > img, .plume-content :not(a) > img"
    }));
  }
  const watermark = options.watermark ?? pluginOptions.watermark;
  if (watermark) {
    plugins.push(watermarkPlugin({
      enabled: true,
      ...isPlainObject9(watermark) ? watermark : {}
    }));
  }
  const comment = options.comment ?? pluginOptions.comment;
  if (comment) {
    plugins.push(commentPlugin(comment));
  }
  if (options.search !== false) {
    const search = (options.search === true ? { provider: "local" } : options.search) ?? (pluginOptions.docsearch ? { provider: "algolia", ...pluginOptions.docsearch } : { provider: "local", ...isPlainObject9(pluginOptions.search) ? pluginOptions.search : {} });
    const { provider, ...searchOptions } = search;
    if (provider === "algolia") {
      if (search.appId && search.apiKey)
        plugins.push(docsearchPlugin(searchOptions));
      else
        console.error("docsearch plugin: appId and apiKey are both required");
    } else {
      plugins.push(searchPlugin(searchOptions));
    }
  }
  if (pluginOptions.git ?? isProd) {
    const excludes = ["home", "friends", "page", "custom", false];
    const changelogOptions = isPlainObject9(options.changelog) ? options.changelog : {};
    plugins.push(gitPlugin({
      createdTime: false,
      updatedTime: options.lastUpdated !== false,
      contributors: isPlainObject9(options.contributors) || options.contributors === true ? {
        avatar: true,
        ...options.contributors === true ? {} : options.contributors
      } : false,
      changelog: options.changelog && options.docsRepo ? { repoUrl: options.docsRepo, ...changelogOptions } : options.changelog,
      filter(page) {
        if (page.frontmatter.home || excludes.includes(page.frontmatter.pageLayout))
          return false;
        return true;
      }
    }));
  }
  const replaceAssets = options.replaceAssets ?? pluginOptions.replaceAssets;
  if (replaceAssets) {
    plugins.push(replaceAssetsPlugin(replaceAssets));
  }
  if (pluginOptions.sitemap !== false && isProd) {
    const sitemapOptions = isPlainObject9(pluginOptions.sitemap) ? pluginOptions.sitemap : {};
    sitemapOptions.hostname ||= hostname;
    if (sitemapOptions.hostname)
      plugins.push(sitemapPlugin(sitemapOptions));
  }
  if (pluginOptions.seo !== false && hostname && isProd) {
    const seoOptions = isPlainObject9(pluginOptions.seo) ? pluginOptions.seo : {};
    seoOptions.hostname ||= hostname;
    if (seoOptions.hostname)
      plugins.push(seoPlugin(seoOptions));
  }
  if (options.cache !== false) {
    plugins.push(cachePlugin({
      ...isPlainObject9(pluginOptions.cache) ? pluginOptions.cache : {},
      type: options.cache || "filesystem"
    }));
  }
  return plugins;
}

// src/node/prepare/index.ts
import { watch as watch2 } from "chokidar";

// src/node/prepare/prepareArticleTagColor.ts
import { toArray as toArray2 } from "@pengzhanbo/utils";
import { isPlainObject as isPlainObject10 } from "vuepress/shared";
var PRESET = [
  ["#6aa1b7", "#5086a1", "rgba(131, 208, 218, 0.314)"],
  ["#299764", "#18794e", "rgba(16, 185, 129, 0.14)"],
  ["#946300", "#915930", "rgba(234, 179, 8, 0.14)"],
  ["#d5393e", "#b8272c", "rgba(244, 63, 94, 0.14)"],
  ["#7e4cc9", "#6f42c1", "rgba(159, 122, 234, 0.14)"],
  ["#3a5ccc", "#3451b2", "rgba(100, 108, 255, 0.14)"],
  ["#fab10f", "#f39c12", "rgba(255, 213, 0, 0.14)"],
  ["#cc6699", "#be3f7f", "rgba(161, 54, 107, 0.14)"],
  ["#55aaee", "#2391e9", "rgba(21, 123, 206, 0.1333)"],
  ["#9933cc", "#aa56d5", "rgba(179, 102, 217, 0.2)"],
  ["#cc3366", "#d55680", "rgba(217, 102, 140, 0.2)"],
  ["#cc9933", "#be7f3f", "rgba(161, 107, 54, 0.2)"],
  ["#9966cc", "#7171b8", "rgba(83, 83, 167, 0.14)"],
  ["#66cccc", "#3fbebe", "rgba(54, 161, 161, 0.14)"],
  ["#3366cc", "#5680d5", "rgba(102, 140, 217, 0.14)"],
  ["#339999", "#41c0c0", "rgba(83, 198, 198, 0.2)"],
  ["#a6623b", "#c17950", "rgba(199, 134, 97, 0.2411)"],
  ["#8ecaef", "#55afe7", "rgba(42, 155, 225, 0.147)"]
];
var cache2 = {};
async function prepareArticleTagColors(app) {
  perf.mark("prepare:tag-colors");
  const options = getThemeConfig();
  const blog = isPlainObject10(options.blog) ? options.blog : {};
  const { js, css } = genCode(app, blog.tagsTheme ?? "colored");
  await writeTemp(app, "internal/articleTagColors.css", css);
  await writeTemp(app, "internal/articleTagColors.js", js);
  perf.log("prepare:tag-colors");
}
function genCode(app, theme) {
  const articleTagColors = {};
  const tagList = /* @__PURE__ */ new Set();
  if (theme !== "colored") {
    return {
      js: resolveContent(app, {
        name: "articleTagColors",
        content: articleTagColors
      }),
      css: ""
    };
  }
  app.pages.forEach((page) => {
    const { frontmatter: { tags } } = page;
    if (tags) {
      toArray2(tags).forEach((tag) => {
        if (tag) {
          tagList.add(tag);
        }
      });
    }
  });
  tagList.forEach((tag) => {
    const code = getTagCode(tag);
    if (!cache2[code]) {
      cache2[code] = nanoid(4);
    }
    if (!articleTagColors[tag]) {
      articleTagColors[tag] = cache2[code];
    }
  });
  const js = resolveContent(app, {
    name: "articleTagColors",
    content: articleTagColors,
    before: `import './articleTagColors.css'`
  });
  const css = genCSS();
  return { js, css };
}
function getTagCode(tag) {
  tag = tag.toLowerCase();
  let code = 0;
  for (let i = 0; i < tag.length; i++) {
    code += tag.charCodeAt(i);
  }
  return code % PRESET.length;
}
function genCSS() {
  let css = "";
  for (const [code, className] of Object.entries(cache2)) {
    const index = Number(code);
    const [color, hoverColor, backgroundColor] = PRESET[index];
    css += `.vp-tag-${className} {
  --vp-tag-color: ${color};
  --vp-tag-hover-color: ${hoverColor};
  --vp-tag-bg: ${backgroundColor};
}
`;
  }
  return css;
}

// src/node/prepare/prepareBlogData.ts
import { removeLeadingSlash as removeLeadingSlash2 } from "@vuepress/helper";
import { createFilter as createFilter2 } from "create-filter";
import dayjs2 from "dayjs";

// src/node/prepare/prepareEncrypt.ts
import { isNumber, isString, random, toArray as toArray3 } from "@pengzhanbo/utils";
import { genSaltSync, hashSync } from "bcrypt-ts";
var isStringLike = (value) => isString(value) || isNumber(value);
var separator = ":";
var contentHash2 = "";
var fsCache = null;
async function prepareEncrypt(app) {
  perf.mark("prepare:encrypt");
  const { encrypt } = getThemeConfig();
  if (!fsCache && app.env.isDev) {
    fsCache = createFsCache(app, "encrypt");
    await fsCache.read();
  }
  contentHash2 = fsCache?.data?.[0] ?? "";
  let resolvedEncrypt = fsCache?.data?.[1];
  const currentHash = encrypt ? hash2(JSON.stringify(encrypt)) : "";
  if (!contentHash2 || contentHash2 !== currentHash || !resolvedEncrypt) {
    contentHash2 = currentHash;
    resolvedEncrypt = resolveEncrypt(encrypt);
  }
  await writeTemp(app, "internal/encrypt.js", resolveContent(app, {
    name: "encrypt",
    content: resolvedEncrypt
  }));
  fsCache?.write([currentHash, resolvedEncrypt]);
  perf.log("prepare:encrypt");
}
var salt = () => genSaltSync(random(8, 16));
function resolveEncrypt(encrypt) {
  const admin = encrypt?.admin ? toArray3(encrypt.admin).filter(isStringLike).map((item) => hashSync(String(item), salt())).join(separator) : "";
  const rules = {};
  const keys = Object.keys(encrypt?.rules ?? {});
  if (encrypt?.rules) {
    Object.keys(encrypt.rules).forEach((key) => {
      const index = keys.indexOf(key);
      rules[String(index)] = toArray3(encrypt.rules[key]).filter(isStringLike).map((item) => hashSync(String(item), salt())).join(separator);
    });
  }
  return [encrypt?.global ?? false, separator, admin, keys, rules];
}
function isEncryptPage(page, encrypt) {
  if (!encrypt)
    return false;
  const rules = encrypt.rules ?? {};
  return Object.keys(rules).some((match) => {
    const relativePath = page.data.filePathRelative || "";
    if (match[0] === "^") {
      const regex = new RegExp(match);
      return regex.test(page.path) || relativePath && regex.test(relativePath);
    }
    if (match.endsWith(".md"))
      return relativePath && relativePath.endsWith(match);
    return page.path.startsWith(match) || relativePath.startsWith(match);
  });
}

// src/node/prepare/prepareBlogData.ts
var HEADING_RE = /<h(\d)[^>]*>.*?<\/h\1>/gi;
var EXCERPT_SPLIT = "<!-- more -->";
function getTimestamp(time) {
  return new Date(time).getTime();
}
async function preparedBlogData(app) {
  const options = getThemeConfig();
  const encrypt = options.encrypt;
  if (options.blog === false) {
    const content2 = resolveContent(app, { name: "blogPostData", content: [] });
    await writeTemp(app, "internal/blogData.js", content2);
    return;
  }
  perf.mark("prepare:blog-data");
  const blog = options.blog || {};
  const notesList = resolveNotesOptions(options);
  const notesDirList = notesList.map((notes) => removeLeadingSlash2(normalizePath(`${notes.dir}/**`))).filter(Boolean);
  const filter = createFilter2(
    blog.include ?? ["**/*.md"],
    [
      "**/{README,readme,index}.md",
      "**/.vuepress/**",
      "**/node_modules/**",
      ...blog.exclude ?? [],
      ...notesDirList
    ].filter(Boolean),
    { resolve: false }
  );
  const pages = app.pages.filter(
    (page) => page.filePathRelative && filter(page.filePathRelative) && page.frontmatter.draft !== true
  ).sort(
    (prev, next) => getTimestamp(prev.frontmatter.createTime || prev.date) < getTimestamp(next.frontmatter.createTime || next.date) ? 1 : -1
  );
  const blogData = pages.map((page) => {
    const tags = page.frontmatter.tags;
    const data = {
      path: page.path,
      title: page.title,
      categoryList: page.data.categoryList,
      tags,
      sticky: page.frontmatter.sticky,
      createTime: dayjs2(new Date(page.data.frontmatter.createTime || page.date)).format("YYYY/MM/DD HH:mm:ss"),
      lang: page.lang,
      excerpt: "",
      cover: page.data.frontmatter.cover,
      coverStyle: page.data.frontmatter.coverStyle
    };
    if (typeof data.cover === "object") {
      logger.warn(`cover should be a path string, please use string instead. (${page.filePathRelative})`);
    }
    if (isEncryptPage(page, encrypt)) {
      data.encrypt = true;
    }
    const fmExcerpt = page.frontmatter.excerpt;
    if (fmExcerpt !== false) {
      if (typeof fmExcerpt === "string") {
        data.excerpt = fmExcerpt;
      } else if (page.contentRendered.includes(EXCERPT_SPLIT)) {
        const contents = page.contentRendered.split(EXCERPT_SPLIT);
        let excerpt = contents[0];
        excerpt = excerpt.replace(HEADING_RE, "");
        data.excerpt = excerpt;
      }
    }
    return data;
  });
  const content = resolveContent(app, { name: "blogPostData", content: blogData });
  await writeTemp(app, "internal/blogData.js", content);
  perf.log("prepare:blog-data");
}

// src/node/prepare/prepareIcons.ts
import { getIconContentCSS, getIconData } from "@iconify/utils";
import { isArray as isArray2, uniq as uniq5 } from "@pengzhanbo/utils";
import { entries as entries4, isLinkAbsolute as isLinkAbsolute2, isLinkHttp, isPlainObject as isPlainObject11 } from "@vuepress/helper";
import { isPackageExists as isPackageExists3 } from "local-pkg";
import { fs as fs8 } from "vuepress/utils";
var ICON_REGEXP = /<(?:VP)?(Icon|Card|LinkCard|Button)([^>]*)>/g;
var ICON_NAME_REGEXP = /(?:name|icon|suffix-icon)="([^"]+)"/;
var URL_CONTENT_REGEXP = /(url\([\s\S]+\))/;
var ICONIFY_NAME = /^[\w-]+:[\w-]+$/;
var JS_FILENAME = "internal/iconify.js";
var CSS_FILENAME = "internal/iconify.css";
var isInstalled = isPackageExists3("@iconify/json");
var locate;
var fsCache2 = null;
var cache3 = {};
function isIconify(icon) {
  if (!icon || typeof icon !== "string" || isLinkAbsolute2(icon) || isLinkHttp(icon))
    return false;
  return icon[0] !== "{" && ICONIFY_NAME.test(icon);
}
async function prepareIcons(app) {
  perf.mark("prepare:icons:total");
  const options = getThemeConfig();
  if (!isInstalled) {
    await writeTemp(app, JS_FILENAME, resolveContent(app, { name: "icons", content: "{}" }));
    return;
  }
  if (!fsCache2 && app.env.isDev) {
    fsCache2 = createFsCache(app, "iconify");
    await fsCache2.read();
  }
  perf.mark("prepare:pages:icons");
  const iconList = [];
  app.pages.forEach((page) => iconList.push(...getIconsWithPage(page)));
  iconList.push(...getIconWithThemeConfig(options));
  const collectMap = {};
  uniq5(iconList).filter((icon) => {
    if (fsCache2?.data?.[icon] && !cache3[icon])
      cache3[icon] = fsCache2.data[icon];
    return !cache3[icon];
  }).forEach((iconName) => {
    const [collect, name] = iconName.split(":");
    if (!collectMap[collect])
      collectMap[collect] = [];
    collectMap[collect].push(name);
  });
  perf.log("prepare:pages:icons");
  perf.mark("prepare:icons:imports");
  if (!locate) {
    const mod = await interopDefault(import("@iconify/json"));
    locate = mod.locate;
  }
  const unknownList = (await Promise.all(
    entries4(collectMap).map(([collect, names]) => resolveCollect(collect, names))
  )).flat();
  if (unknownList.length) {
    logger.warn(`[iconify] Unknown icons: ${unknownList.join(", ")}`);
  }
  perf.log("prepare:icons:imports");
  let cssCode = "";
  const map = {};
  for (const [iconName, { className, content, background }] of entries4(cache3)) {
    map[iconName] = `${className}${background ? " bg" : ""}`;
    cssCode += `.${className} {
  --icon: ${content};
}
`;
  }
  await Promise.all([
    writeTemp(app, CSS_FILENAME, cssCode),
    writeTemp(app, JS_FILENAME, resolveContent(app, {
      name: "icons",
      content: map,
      before: `import './iconify.css'`
    }))
  ]);
  fsCache2?.write(cache3);
  perf.log("prepare:icons:total");
}
function getIconsWithPage(page) {
  const list = page.contentRendered.match(ICON_REGEXP)?.map((match) => match.match(ICON_NAME_REGEXP)?.[1]).filter(isIconify) || [];
  const fm = page.frontmatter;
  if (fm.icon && isIconify(fm.icon)) {
    list.push(fm.icon);
  }
  if ((fm.home || fm.pageLayout === "home") && fm.config?.length) {
    for (const config of fm.config) {
      if (config.type === "features" && config.features.length) {
        for (const feature of config.features) {
          if (feature.icon && isIconify(feature.icon))
            list.push(feature.icon);
        }
      }
      if (config.type === "hero" && config.hero?.actions?.length) {
        for (const action of config.hero.actions) {
          if (action.icon && isIconify(action.icon))
            list.push(action.icon);
          if (action.suffixIcon && isIconify(action.suffixIcon))
            list.push(action.suffixIcon);
        }
      }
    }
  }
  return list;
}
function getIconWithThemeConfig(options) {
  const list = [];
  const locales = options.locales || {};
  entries4(locales).forEach(([, { navbar, sidebar, notes }]) => {
    if (navbar) {
      list.push(...getIconWithNavbar(navbar));
    }
    const sidebarList = Object.values(sidebar || {});
    if (notes) {
      notes.notes.forEach((note) => {
        if (note.sidebar)
          sidebarList.push(note.sidebar);
      });
    }
    sidebarList.forEach((sidebar2) => list.push(...getIconWithSidebar(sidebar2)));
  });
  return list.filter(isIconify);
}
function getIconWithNavbar(navbar) {
  const list = [];
  navbar.forEach((item) => {
    if (typeof item !== "string") {
      if (isIconify(item.icon))
        list.push(item.icon);
      if (item.items?.length)
        list.push(...getIconWithNavbar(item.items));
    }
  });
  return list;
}
function getIconWithSidebar(sidebar) {
  const list = [];
  if (isArray2(sidebar)) {
    sidebar.forEach((item) => {
      if (typeof item !== "string") {
        if (isIconify(item.icon))
          list.push(item.icon);
        if (item.items?.length)
          list.push(...getIconWithSidebar(item.items));
      }
    });
  } else if (isPlainObject11(sidebar)) {
    entries4(sidebar).forEach(([, item]) => {
      if (typeof item !== "string") {
        if (isArray2(item)) {
          list.push(...getIconWithSidebar(item));
        } else if (item.items?.length) {
          list.push(...getIconWithSidebar(item.items));
        }
      }
    });
  }
  return list;
}
async function resolveCollect(collect, names) {
  const filepath = locate(collect);
  const config = await readJSON(filepath);
  if (!config) {
    logger.warn(`[iconify] Can not find icon collect: ${collect}!`);
    return [];
  }
  const unknownList = [];
  for (const name of names) {
    const data = getIconData(config, name);
    const icon = `${collect}:${name}`;
    if (!data) {
      unknownList.push(icon);
    } else if (!cache3[icon]) {
      const content = getIconContentCSS(data, {
        height: data.height || 24
      });
      const matched = content.match(URL_CONTENT_REGEXP)?.[1] ?? "";
      const background = !data.body.includes("currentColor");
      cache3[icon] = {
        className: `vpi-${nanoid()}`,
        background,
        content: matched
      };
    }
  }
  return unknownList;
}
async function readJSON(filepath) {
  try {
    return await fs8.readJSON(filepath, "utf-8");
  } catch {
    return null;
  }
}

// src/node/prepare/prepareSidebar.ts
import {
  entries as entries5,
  isArray as isArray3,
  isPlainObject as isPlainObject12,
  removeLeadingSlash as removeLeadingSlash3
} from "@vuepress/helper";
async function prepareSidebar(app) {
  perf.mark("prepare:sidebar");
  const options = getThemeConfig();
  const sidebar = getAllSidebar(options);
  const { resolved, autoHome } = getSidebarData(app, sidebar);
  sidebar.__auto__ = resolved;
  sidebar.__home__ = autoHome;
  await writeTemp(app, "internal/sidebar.js", resolveContent(app, { name: "sidebar", content: sidebar }));
  perf.log("prepare:sidebar");
}
function getSidebarData(app, locales) {
  const autoDirList = [];
  const resolved = {};
  entries5(locales).forEach(([localePath, sidebar]) => {
    if (!sidebar)
      return;
    if (isArray3(sidebar)) {
      autoDirList.push(...findAutoDirList(sidebar));
    } else if (isPlainObject12(sidebar)) {
      entries5(sidebar).forEach(([dirname, config]) => {
        const prefix = normalizeLink(localePath, dirname);
        if (config === "auto") {
          autoDirList.push(prefix);
        } else if (isArray3(config)) {
          autoDirList.push(...findAutoDirList(config, prefix));
        } else if (config.items === "auto") {
          autoDirList.push(normalizeLink(prefix, config.prefix));
        } else {
          autoDirList.push(
            ...findAutoDirList(
              config.items || [],
              normalizeLink(prefix, config.prefix)
            )
          );
        }
      });
    } else if (sidebar === "auto") {
      autoDirList.push(localePath);
    }
  });
  const autoHome = {};
  autoDirList.forEach((localePath) => {
    const { link, sidebar } = getAutoDirSidebar(app, localePath);
    resolved[localePath] = sidebar;
    if (link) {
      autoHome[localePath] = link;
    }
  });
  return { resolved, autoHome };
}
var MD_RE = /\.md$/;
var NUMBER_RE = /^\d+\./;
function resolveTitle(dirname) {
  return dirname.replace(MD_RE, "").replace(NUMBER_RE, "");
}
var RE_FILE_SORTING = /(?:(\d+)\.)?(?=[^/]+$)/;
function fileSorting(filepath) {
  if (!filepath)
    return false;
  const matched = filepath.match(RE_FILE_SORTING);
  const sorted = matched ? Number(matched[1]) : 0;
  if (Number.isNaN(sorted))
    return Number.MAX_SAFE_INTEGER;
  return sorted;
}
function getAutoDirSidebar(app, localePath) {
  const locale = removeLeadingSlash3(localePath);
  let pages = app.pages.filter((page) => page.data.filePathRelative?.startsWith(locale)).map((page) => {
    return { ...page, splitPath: page.data.filePathRelative?.split("/") || [] };
  });
  const maxIndex = Math.max(...pages.map((page) => page.splitPath.length));
  let nowIndex = maxIndex - 1;
  while (nowIndex >= 0) {
    pages = pages.sort((prev, next) => {
      const pi = fileSorting(prev.splitPath?.[nowIndex]);
      const ni = fileSorting(next.splitPath?.[nowIndex]);
      if (pi === false || ni === false)
        return 0;
      if (pi === ni)
        return 0;
      return pi < ni ? -1 : 1;
    });
    nowIndex--;
  }
  const RE_INDEX = ["index.md", "README.md", "readme.md"];
  const sidebar = [];
  let rootLink = "";
  for (const page of pages) {
    const { data, title, path: path10, frontmatter } = page;
    const paths = (data.filePathRelative || "").slice(localePath.replace(/^\/|\/$/g, "").length + 1).split("/");
    let index = 0;
    let dir;
    let items = sidebar;
    let parent;
    while (dir = paths[index]) {
      const text = resolveTitle(dir);
      const isHome = RE_INDEX.includes(dir);
      let current = items.find((item) => item.text === text);
      if (!current) {
        current = { text, link: void 0, items: [] };
        if (!isHome) {
          items.push(current);
        }
      }
      if (dir.endsWith(".md")) {
        if (isHome) {
          if (parent) {
            parent.link = path10;
          } else {
            rootLink = path10;
          }
        } else {
          current.link = path10;
          current.text = title;
        }
      }
      if (frontmatter.icon) {
        current.icon = frontmatter.icon;
      }
      if (parent?.items?.length) {
        parent.collapsed = false;
      }
      parent = current;
      items = current.items;
      index++;
    }
  }
  return { link: rootLink, sidebar: cleanSidebar(sidebar) };
}
function cleanSidebar(sidebar) {
  for (const item of sidebar) {
    if (isPlainObject12(item)) {
      if (isArray3(item.items)) {
        if (item.items.length === 0) {
          delete item.items;
        } else {
          cleanSidebar(item.items);
        }
      }
    }
  }
  return sidebar;
}
function findAutoDirList(sidebar, prefix = "") {
  const list = [];
  if (!sidebar.length)
    return list;
  sidebar.forEach((item) => {
    if (isPlainObject12(item)) {
      const nextPrefix = normalizeLink(prefix, item.prefix || item.dir);
      if (item.items === "auto") {
        list.push(nextPrefix);
      } else if (item.items?.length) {
        list.push(...findAutoDirList(item.items, nextPrefix));
      }
    }
  });
  return list;
}
function getAllSidebar(options) {
  const locales = {};
  for (const [locale, opt] of entries5(options.locales || {})) {
    const notes = locale === "/" ? opt.notes || options.notes : opt.notes;
    const sidebar = locale === "/" ? opt.sidebar || options.sidebar : opt.sidebar;
    locales[locale] = {};
    for (const [key, value] of entries5(sidebar || {})) {
      locales[locale][normalizeLink(key)] = value;
    }
    if (notes && notes.notes?.length) {
      const prefix = notes.link || "";
      for (const note of notes.notes) {
        if (note.sidebar) {
          locales[locale][normalizeLink(prefix, note.link || "/")] = {
            items: note.sidebar,
            prefix: normalizeLink(notes.dir, note.dir)
          };
        }
      }
    }
  }
  return locales;
}

// src/node/prepare/index.ts
async function prepareData(app) {
  perf.mark("prepare:data");
  await Promise.all([
    prepareArticleTagColors(app),
    preparedBlogData(app),
    prepareSidebar(app),
    prepareEncrypt(app),
    prepareIcons(app)
  ]);
  perf.log("prepare:data");
}
function watchPrepare(app, watchers) {
  const pagesWatcher = watch2("pages/**/*.js", {
    cwd: app.dir.temp(),
    ignoreInitial: true
  });
  watchers.push(pagesWatcher);
  pagesWatcher.on("change", () => prepareData(app));
  pagesWatcher.on("add", () => prepareData(app));
  pagesWatcher.on("unlink", () => prepareData(app));
}

// src/node/prepare/prepareThemeData.ts
import fs9 from "node:fs/promises";
import process5 from "node:process";
import { watch as watch3 } from "chokidar";
import { resolveImageSize } from "vuepress-plugin-md-power";
import { hash as hash4 } from "vuepress/utils";
var bulletinFileWatcher = null;
var bulletinFiles = {};
process5.on("exit", () => bulletinFileWatcher?.close());
async function prepareThemeData(app, plugins) {
  perf.mark("prepare:theme-data");
  const options = getThemeConfig();
  const resolvedThemeData = resolveThemeData(app, options);
  await processProfileImageSize(app, resolvedThemeData, plugins);
  if (bulletinFileWatcher) {
    bulletinFileWatcher.close();
    bulletinFileWatcher = null;
  }
  await resolveBulletin(app, resolvedThemeData);
  await updateThemeData(app, resolvedThemeData);
  perf.log("prepare:theme-data");
}
async function updateThemeData(app, themeData) {
  const content = resolveContent(app, { name: "themeData", content: themeData });
  await writeTemp(app, "internal/themePlumeData.js", content);
}
async function resolveBulletin(app, themeData) {
  if (themeData.bulletin === true)
    themeData.bulletin = {};
  if (themeData.bulletin)
    themeData.bulletin.id ||= hash4(themeData.bulletin);
  if (themeData.bulletin) {
    if (bulletinFiles.root || themeData.bulletin.contentFile) {
      bulletinFiles.root = themeData.bulletin.contentFile || bulletinFiles.root;
      delete themeData.bulletin.contentFile;
      themeData.bulletin.content = await readBulletinFile(app, bulletinFiles.root);
    } else if (themeData.bulletin.content) {
      const type = themeData.bulletin.contentType ?? "text";
      themeData.bulletin.content = type === "markdown" ? app.markdown.render(themeData.bulletin.content, {
        filepath: app.dir.source(`/_bulletin.md`),
        filePathRelative: `_bulletin.md`
      }) : themeData.bulletin.content;
    }
  }
  if (themeData.locales) {
    for (const locale of Object.keys(themeData.locales)) {
      if (themeData.locales[locale].bulletin === true)
        themeData.locales[locale].bulletin = {};
      if (themeData.locales[locale].bulletin)
        themeData.locales[locale].bulletin.id ||= hash4(themeData.locales[locale].bulletin);
      if (!themeData.locales[locale].bulletin)
        continue;
      if (bulletinFiles[locale] || themeData.locales[locale].bulletin.contentFile) {
        bulletinFiles[locale] = themeData.locales[locale].bulletin?.contentFile || bulletinFiles[locale];
        delete themeData.locales[locale].bulletin.contentFile;
        themeData.locales[locale].bulletin.content = await readBulletinFile(app, bulletinFiles[locale], locale);
      } else if (themeData.locales[locale].bulletin.content) {
        const type = themeData.locales[locale].bulletin.contentType ?? "text";
        themeData.locales[locale].bulletin.content = type === "markdown" ? app.markdown.render(themeData.locales[locale].bulletin.content, {
          filepath: app.dir.source(`${locale}_bulletin.md`),
          filePathRelative: `${locale.slice(1)}_bulletin.md`
        }) : themeData.locales[locale].bulletin.content;
      }
    }
  }
  const files = Array.from(new Set(Object.values(bulletinFiles)));
  if (app.env.isDev && files.length) {
    if (!bulletinFileWatcher) {
      bulletinFileWatcher = watch3(files, { ignoreInitial: true });
      bulletinFileWatcher.on("change", async () => {
        await resolveBulletin(app, themeData);
        await updateThemeData(app, themeData);
      });
    } else {
      files.forEach((file) => bulletinFileWatcher?.add(file));
    }
  }
}
async function readBulletinFile(app, filepath, locale = "/") {
  try {
    const content = await fs9.readFile(filepath, "utf-8");
    if (filepath.endsWith(".md")) {
      return app.markdown.render(content, {
        filepath: app.dir.source(`${locale}_bulletin.md`),
        filePathRelative: `${locale.slice(1)}_bulletin.md`
      });
    }
    return content;
  } catch {
  }
  return "";
}
async function processProfileImageSize(app, themeData, plugins) {
  const options = getThemeConfig();
  const imageSize = options.markdown?.imageSize ?? (typeof plugins.markdownPower === "boolean" ? false : plugins.markdownPower?.imageSize);
  if (!app.env.isBuild || !imageSize)
    return;
  const remote = imageSize === "all";
  if (themeData.profile?.avatar) {
    const { width, height } = await resolveImageSize(app, themeData.profile.avatar, remote);
    if (width && height) {
      themeData.profile = {
        ...themeData.profile,
        originalWidth: width,
        originalHeight: height
      };
    }
  }
  if (themeData.locales) {
    for (const locale of Object.keys(themeData.locales)) {
      if (themeData.locales[locale].profile?.avatar) {
        const { width, height } = await resolveImageSize(app, themeData.locales[locale].profile.avatar, remote);
        if (width && height) {
          themeData.locales[locale].profile = {
            ...themeData.locales[locale].profile,
            originalWidth: width,
            originalHeight: height
          };
        }
      }
    }
  }
}

// src/node/theme.ts
function plumeTheme(options = {}) {
  return (app) => {
    setTranslateLang(app.options.lang);
    perf.init(app.env.isDebug);
    detectVersions(app);
    const { configFile, plugins, themeOptions } = detectThemeOptions(options);
    initConfigLoader(app, {
      configFile,
      defaultConfig: themeOptions,
      onChange: initAutoFrontmatter
    });
    return {
      name: THEME_NAME,
      define: setupProvideData(app, plugins),
      templateBuild: templates("build.html"),
      clientConfigFile: resolve("client/config.js"),
      alias: setupAlias(),
      plugins: setupPlugins(app, plugins),
      extendsBundlerOptions,
      templateBuildRenderer,
      extendsMarkdown: async (_, app2) => {
        const { autoFrontmatter } = await waitForConfigLoaded();
        if (autoFrontmatter !== false) {
          initAutoFrontmatter();
          await generateAutoFrontmatter(app2);
          await sleep(100);
        }
      },
      extendsPage: (page) => extendsPageData(page),
      onInitialized: async (app2) => await createPages(app2),
      onPrepared: async (app2) => {
        await prepareThemeData(app2, plugins);
        await prepareData(app2);
      },
      onWatched: (app2, watchers) => {
        watchConfigFile(app2, watchers, async () => {
          await prepareThemeData(app2, plugins);
          await prepareData(app2);
        });
        watchAutoFrontmatter(app2, watchers);
        watchPrepare(app2, watchers);
      }
    };
  };
}

// src/node/index.ts
export * from "../shared/index.js";

// src/node/defineConfig.ts
function defineThemeConfig(config) {
  return config;
}
function defineNavbarConfig(navbar) {
  return navbar;
}
function defineNotesConfig(notes) {
  return notes;
}
function defineNoteConfig(note) {
  return note;
}

// src/node/index.ts
var index_default = plumeTheme;
export {
  index_default as default,
  defineNavbarConfig,
  defineNoteConfig,
  defineNotesConfig,
  defineThemeConfig,
  plumeTheme
};
