/**
 * Function Helpers
 *
 * @module Function
 */
import type { Fn, Nullable } from './types';
/**
 * noop function
 *
 * 空函数
 *
 * @category Function
 */
export declare function noop(): void;
/**
 * Create a function that can only be called once,
 * and repeated calls return the result of the first call
 *
 * 创建只能被调用一次的函数，重复调用返回第一次调用的结果
 *
 * @category Function
 */
export declare function once(func: Fn): Fn;
/**
 * guard function that returns if val is truthy
 *
 * 守卫函数，返回 val 是否为真值
 *
 * @category Function
 * @example
 * ```ts
 * [1, 2, 3, '', false, undefined].filter(isTruthy) // => [1, 2, 3]
 * ```
 */
export declare function isTruthy(val: unknown): boolean;
/**
 * guard function that returns if val is not undefined
 *
 * 守卫函数，返回 val 不为 undefined
 *
 * @category Function
 * @example
 * ```ts
 * [1, '', false, undefined].filter(NotUndefined) // => [1, '', false]
 * ```
 */
export declare function notUndefined(val: unknown): boolean;
/**
 * call the function
 *
 * 调用函数
 *
 * @category Function
 */
export declare function invoke<T>(fn: Fn<T>): T;
/**
 * call every functions in an array
 *
 * 调用数组中的每个函数
 *
 * @category Function
 *
 * @param fns - an array of functions
 */
export declare function invoke(fns: Nullable<Fn>[]): void;
type ComposeFn = (...args: any[]) => any;
type LastArray<T extends any[]> = T extends [...any[], infer U] ? U : Fn;
type FirstArray<T extends any[]> = T extends [infer U, ...any[]] ? U : Fn;
/**
 * compose multiple functions, right to left
 *
 * 组合多个函数，从右到左执行
 *
 * @category Function
 * @example
 * ```ts
 * const add = (a) => a + 1
 * const subtract = (a) => a - 2
 * const multiply = (a, b) => a * b
 * compose(add, subtract, multiply)(1, 2) => (1 * 2) - 2 + 1 = 1
 * ```
 */
export declare function compose<T extends ComposeFn[] = ComposeFn[]>(...fns: T): (...args: Parameters<LastArray<T>>) => ReturnType<FirstArray<T>>;
export {};
