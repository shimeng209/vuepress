import { isArray, isPlainObject } from "./is.mjs";
export function hasOwn(obj, key) {
  return obj === null ? false : Object.prototype.hasOwnProperty.call(obj, key);
}
export function deepFreeze(obj) {
  if (isArray(obj)) {
    obj.forEach((item) => deepFreeze(item));
  } else if (isPlainObject(obj)) {
    Object.freeze(obj);
    Object.keys(obj).forEach((key) => deepFreeze(obj[key]));
  }
  return obj;
}
export function isKeyof(obj, key) {
  return key in obj;
}
export function objectGet(source, path) {
  const keys = path.replace(/\[['"]?(.+?)['"]?\]/g, ".$1").split(".");
  let res = source;
  for (const k of keys)
    res = res?.[k];
  return res;
}
export function omit(obj, keys) {
  const res = { ...obj };
  for (const key of keys) {
    if (isKeyof(obj, key))
      delete res[key];
  }
  return res;
}
export function pick(obj, keys) {
  const res = {};
  for (const key of keys) {
    if (isKeyof(obj, key))
      res[key] = obj[key];
  }
  return res;
}
export function deepMerge(target, ...sources) {
  if (!sources.length)
    return target;
  const source = sources.shift();
  if (source === void 0)
    return target;
  if (isMergableObject(target) && isMergableObject(source)) {
    Object.keys(source).forEach((key) => {
      if (key === "__proto__" || key === "constructor" || key === "prototype")
        return;
      if (isMergableObject(source[key])) {
        if (!target[key])
          target[key] = {};
        deepMerge(target[key], source[key]);
      } else {
        target[key] = source[key];
      }
    });
  }
  return deepMerge(target, ...sources);
}
export function deepMergeWithArray(target, ...sources) {
  if (!sources.length)
    return target;
  const source = sources.shift();
  if (source === void 0)
    return target;
  if (Array.isArray(target) && Array.isArray(source))
    target.push(...source);
  if (isMergableObject(target) && isMergableObject(source)) {
    Object.keys(source).forEach((key) => {
      if (key === "__proto__" || key === "constructor" || key === "prototype")
        return;
      if (Array.isArray(source[key])) {
        if (!target[key])
          target[key] = [];
        deepMergeWithArray(target[key], source[key]);
      } else if (isMergableObject(source[key])) {
        if (!target[key])
          target[key] = {};
        deepMergeWithArray(target[key], source[key]);
      } else {
        target[key] = source[key];
      }
    });
  }
  return deepMergeWithArray(target, ...sources);
}
function isMergableObject(item) {
  return isPlainObject(item) && !Array.isArray(item);
}
